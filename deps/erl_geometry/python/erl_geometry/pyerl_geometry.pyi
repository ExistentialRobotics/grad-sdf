"""
Python 3 Interface of erl_geometry
"""
from __future__ import annotations
import numpy
import torch
import typing
__all__: list[str] = ['Aabb2Dd', 'Aabb2Df', 'Aabb3Dd', 'Aabb3Df', 'AbstractOccupancyOctreeD', 'AbstractOccupancyOctreeF', 'AbstractOccupancyQuadtreeD', 'AbstractOccupancyQuadtreeF', 'AbstractOctreeD', 'AbstractOctreeF', 'AbstractOctreeNode', 'AbstractQuadtreeD', 'AbstractQuadtreeF', 'AbstractQuadtreeNode', 'AxisAlignedRectangle2D', 'Box', 'CameraBase3Dd', 'CameraBase3Df', 'CameraIntrinsicD', 'CameraIntrinsicF', 'CityStreetMap', 'DepthCamera3Dd', 'DepthCamera3Df', 'DepthFrame3Dd', 'DepthFrame3Df', 'Ellipse2D', 'Ellipsoid', 'HouseExpoMap', 'Lidar2D', 'Lidar3Dd', 'Lidar3Df', 'LidarFrame2Dd', 'LidarFrame2Df', 'LidarFrame3Dd', 'LidarFrame3Df', 'Line2D', 'LogOddMap', 'LogOddMap2Dd', 'LogOddMap2Df', 'MarchingCubes', 'MeshSdf', 'NdTreeSetting', 'OccupancyNdTreeSetting', 'OccupancyOctreeBaseSetting', 'OccupancyOctreeD', 'OccupancyOctreeDrawerSetting', 'OccupancyOctreeF', 'OccupancyOctreeNode', 'OccupancyQuadtreeBaseSetting', 'OccupancyQuadtreeD', 'OccupancyQuadtreeDrawerSettingD', 'OccupancyQuadtreeDrawerSettingF', 'OccupancyQuadtreeF', 'OccupancyQuadtreeNode', 'OctreeKey', 'Primitive2D', 'Primitive3D', 'PyObjectOccupancyOctreeD', 'PyObjectOccupancyOctreeF', 'PyObjectOccupancyOctreeNode', 'PyObjectOccupancyQuadtreeD', 'PyObjectOccupancyQuadtreeF', 'PyObjectOccupancyQuadtreeNode', 'QuadtreeKey', 'RangeSensor3Dd', 'RangeSensor3Df', 'RangeSensorFrame3Dd', 'RangeSensorFrame3Df', 'Ray2D', 'Rectangle2D', 'RgbdCamera3Dd', 'RgbdCamera3Df', 'RgbdFrame3Dd', 'RgbdFrame3Df', 'Segment2D', 'SemiSparseNdTreeSetting', 'SemiSparseOctreeD', 'SemiSparseOctreeF', 'SemiSparseOctreeNode', 'SemiSparseQuadtreeD', 'SemiSparseQuadtreeF', 'SemiSparseQuadtreeNode', 'Space2D', 'Surface2D', 'TrajectoryD', 'TrajectoryF', 'YamlableBase', 'bresenham_2d', 'compute_intersection_between_line_and_ellipse_2d', 'compute_intersection_between_line_and_ellipsoid_3d', 'compute_intersection_between_ray_and_aabb_2d', 'compute_intersection_between_ray_and_aabb_3d', 'compute_intersection_between_ray_and_line_2d', 'compute_nearest_distance_from_point_to_line_segment_2d', 'compute_pixels_of_polygon_contour', 'convert_path_2d_to_3d_float32', 'convert_path_2d_to_3d_float64', 'create_ellipsoid_mesh', 'find_voxel_indices', 'hidden_point_removal', 'marching_square', 'morton_decode', 'morton_encode', 'parallel_hidden_point_removal', 'winding_number']
class Aabb2Dd:
    class CornerType:
        """
        Type of corners.
        
        Members:
        
          kBottomLeft
        
          kBottomRight
        
          kTopLeft
        
          kTopRight
        """
        __members__: typing.ClassVar[dict[str, Aabb2Dd.CornerType]]  # value = {'kBottomLeft': <CornerType.kBottomLeft: 0>, 'kBottomRight': <CornerType.kBottomRight: 1>, 'kTopLeft': <CornerType.kTopLeft: 2>, 'kTopRight': <CornerType.kTopRight: 3>}
        kBottomLeft: typing.ClassVar[Aabb2Dd.CornerType]  # value = <CornerType.kBottomLeft: 0>
        kBottomRight: typing.ClassVar[Aabb2Dd.CornerType]  # value = <CornerType.kBottomRight: 1>
        kTopLeft: typing.ClassVar[Aabb2Dd.CornerType]  # value = <CornerType.kTopLeft: 2>
        kTopRight: typing.ClassVar[Aabb2Dd.CornerType]  # value = <CornerType.kTopRight: 3>
        def __and__(self, other: typing.Any) -> typing.Any:
            ...
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __ge__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __gt__(self, other: typing.Any) -> bool:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __invert__(self) -> typing.Any:
            ...
        def __le__(self, other: typing.Any) -> bool:
            ...
        def __lt__(self, other: typing.Any) -> bool:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __or__(self, other: typing.Any) -> typing.Any:
            ...
        def __rand__(self, other: typing.Any) -> typing.Any:
            ...
        def __repr__(self) -> str:
            ...
        def __ror__(self, other: typing.Any) -> typing.Any:
            ...
        def __rxor__(self, other: typing.Any) -> typing.Any:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        def __xor__(self, other: typing.Any) -> typing.Any:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    kBottomLeft: typing.ClassVar[Aabb2Dd.CornerType]  # value = <CornerType.kBottomLeft: 0>
    kBottomRight: typing.ClassVar[Aabb2Dd.CornerType]  # value = <CornerType.kBottomRight: 1>
    kTopLeft: typing.ClassVar[Aabb2Dd.CornerType]  # value = <CornerType.kTopLeft: 2>
    kTopRight: typing.ClassVar[Aabb2Dd.CornerType]  # value = <CornerType.kTopRight: 3>
    @staticmethod
    def intersects(*args, **kwargs) -> bool:
        ...
    @typing.overload
    def __contains__(self, point: numpy.ndarray[numpy.float64[2, 1]]) -> bool:
        ...
    @typing.overload
    def __contains__(self, another_aabb: Aabb2Dd) -> bool:
        ...
    @typing.overload
    def __init__(self, center: numpy.ndarray[numpy.float64[2, 1]], half_size: float) -> None:
        ...
    @typing.overload
    def __init__(self, min: numpy.ndarray[numpy.float64[2, 1]], max: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    def corner(self, corner_type: Aabb2Dd.CornerType) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def padding(self, padding: numpy.ndarray[numpy.float64[2, 1]]) -> Aabb2Dd:
        ...
    @typing.overload
    def padding(self, padding: float) -> Aabb2Dd:
        ...
    @property
    def center(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def half_sizes(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def max(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def min(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class Aabb2Df:
    class CornerType:
        """
        Type of corners.
        
        Members:
        
          kBottomLeft
        
          kBottomRight
        
          kTopLeft
        
          kTopRight
        """
        __members__: typing.ClassVar[dict[str, Aabb2Df.CornerType]]  # value = {'kBottomLeft': <CornerType.kBottomLeft: 0>, 'kBottomRight': <CornerType.kBottomRight: 1>, 'kTopLeft': <CornerType.kTopLeft: 2>, 'kTopRight': <CornerType.kTopRight: 3>}
        kBottomLeft: typing.ClassVar[Aabb2Df.CornerType]  # value = <CornerType.kBottomLeft: 0>
        kBottomRight: typing.ClassVar[Aabb2Df.CornerType]  # value = <CornerType.kBottomRight: 1>
        kTopLeft: typing.ClassVar[Aabb2Df.CornerType]  # value = <CornerType.kTopLeft: 2>
        kTopRight: typing.ClassVar[Aabb2Df.CornerType]  # value = <CornerType.kTopRight: 3>
        def __and__(self, other: typing.Any) -> typing.Any:
            ...
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __ge__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __gt__(self, other: typing.Any) -> bool:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __invert__(self) -> typing.Any:
            ...
        def __le__(self, other: typing.Any) -> bool:
            ...
        def __lt__(self, other: typing.Any) -> bool:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __or__(self, other: typing.Any) -> typing.Any:
            ...
        def __rand__(self, other: typing.Any) -> typing.Any:
            ...
        def __repr__(self) -> str:
            ...
        def __ror__(self, other: typing.Any) -> typing.Any:
            ...
        def __rxor__(self, other: typing.Any) -> typing.Any:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        def __xor__(self, other: typing.Any) -> typing.Any:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    kBottomLeft: typing.ClassVar[Aabb2Df.CornerType]  # value = <CornerType.kBottomLeft: 0>
    kBottomRight: typing.ClassVar[Aabb2Df.CornerType]  # value = <CornerType.kBottomRight: 1>
    kTopLeft: typing.ClassVar[Aabb2Df.CornerType]  # value = <CornerType.kTopLeft: 2>
    kTopRight: typing.ClassVar[Aabb2Df.CornerType]  # value = <CornerType.kTopRight: 3>
    @staticmethod
    def intersects(*args, **kwargs) -> bool:
        ...
    @typing.overload
    def __contains__(self, point: numpy.ndarray[numpy.float32[2, 1]]) -> bool:
        ...
    @typing.overload
    def __contains__(self, another_aabb: Aabb2Df) -> bool:
        ...
    @typing.overload
    def __init__(self, center: numpy.ndarray[numpy.float32[2, 1]], half_size: float) -> None:
        ...
    @typing.overload
    def __init__(self, min: numpy.ndarray[numpy.float32[2, 1]], max: numpy.ndarray[numpy.float32[2, 1]]) -> None:
        ...
    def corner(self, corner_type: Aabb2Df.CornerType) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @typing.overload
    def padding(self, padding: numpy.ndarray[numpy.float32[2, 1]]) -> Aabb2Df:
        ...
    @typing.overload
    def padding(self, padding: float) -> Aabb2Df:
        ...
    @property
    def center(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def half_sizes(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def max(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def min(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
class Aabb3Dd:
    class CornerType:
        """
        Type of corners.
        
        Members:
        
          kBottomLeftFloor
        
          kBottomRightFloor
        
          kTopLeftFloor
        
          kTopRightFloor
        
          kBottomLeftCeil
        
          kBottomRightCeil
        
          kTopLeftCeil
        
          kTopRightCeil
        """
        __members__: typing.ClassVar[dict[str, Aabb3Dd.CornerType]]  # value = {'kBottomLeftFloor': <CornerType.kBottomLeftFloor: 0>, 'kBottomRightFloor': <CornerType.kBottomRightFloor: 1>, 'kTopLeftFloor': <CornerType.kTopLeftFloor: 2>, 'kTopRightFloor': <CornerType.kTopRightFloor: 3>, 'kBottomLeftCeil': <CornerType.kBottomLeftCeil: 4>, 'kBottomRightCeil': <CornerType.kBottomRightCeil: 5>, 'kTopLeftCeil': <CornerType.kTopLeftCeil: 6>, 'kTopRightCeil': <CornerType.kTopRightCeil: 7>}
        kBottomLeftCeil: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kBottomLeftCeil: 4>
        kBottomLeftFloor: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kBottomLeftFloor: 0>
        kBottomRightCeil: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kBottomRightCeil: 5>
        kBottomRightFloor: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kBottomRightFloor: 1>
        kTopLeftCeil: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kTopLeftCeil: 6>
        kTopLeftFloor: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kTopLeftFloor: 2>
        kTopRightCeil: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kTopRightCeil: 7>
        kTopRightFloor: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kTopRightFloor: 3>
        def __and__(self, other: typing.Any) -> typing.Any:
            ...
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __ge__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __gt__(self, other: typing.Any) -> bool:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __invert__(self) -> typing.Any:
            ...
        def __le__(self, other: typing.Any) -> bool:
            ...
        def __lt__(self, other: typing.Any) -> bool:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __or__(self, other: typing.Any) -> typing.Any:
            ...
        def __rand__(self, other: typing.Any) -> typing.Any:
            ...
        def __repr__(self) -> str:
            ...
        def __ror__(self, other: typing.Any) -> typing.Any:
            ...
        def __rxor__(self, other: typing.Any) -> typing.Any:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        def __xor__(self, other: typing.Any) -> typing.Any:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    kBottomLeftCeil: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kBottomLeftCeil: 4>
    kBottomLeftFloor: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kBottomLeftFloor: 0>
    kBottomRightCeil: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kBottomRightCeil: 5>
    kBottomRightFloor: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kBottomRightFloor: 1>
    kTopLeftCeil: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kTopLeftCeil: 6>
    kTopLeftFloor: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kTopLeftFloor: 2>
    kTopRightCeil: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kTopRightCeil: 7>
    kTopRightFloor: typing.ClassVar[Aabb3Dd.CornerType]  # value = <CornerType.kTopRightFloor: 3>
    @staticmethod
    def intersects(*args, **kwargs) -> bool:
        ...
    @typing.overload
    def __contains__(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> bool:
        ...
    @typing.overload
    def __contains__(self, another_aabb: Aabb3Dd) -> bool:
        ...
    @typing.overload
    def __init__(self, center: numpy.ndarray[numpy.float64[3, 1]], half_size: float) -> None:
        ...
    @typing.overload
    def __init__(self, min: numpy.ndarray[numpy.float64[3, 1]], max: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def corner(self, corner_type: Aabb3Dd.CornerType) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def padding(self, padding: numpy.ndarray[numpy.float64[3, 1]]) -> Aabb3Dd:
        ...
    @typing.overload
    def padding(self, padding: float) -> Aabb3Dd:
        ...
    @property
    def center(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def half_sizes(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def max(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def min(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class Aabb3Df:
    class CornerType:
        """
        Type of corners.
        
        Members:
        
          kBottomLeftFloor
        
          kBottomRightFloor
        
          kTopLeftFloor
        
          kTopRightFloor
        
          kBottomLeftCeil
        
          kBottomRightCeil
        
          kTopLeftCeil
        
          kTopRightCeil
        """
        __members__: typing.ClassVar[dict[str, Aabb3Df.CornerType]]  # value = {'kBottomLeftFloor': <CornerType.kBottomLeftFloor: 0>, 'kBottomRightFloor': <CornerType.kBottomRightFloor: 1>, 'kTopLeftFloor': <CornerType.kTopLeftFloor: 2>, 'kTopRightFloor': <CornerType.kTopRightFloor: 3>, 'kBottomLeftCeil': <CornerType.kBottomLeftCeil: 4>, 'kBottomRightCeil': <CornerType.kBottomRightCeil: 5>, 'kTopLeftCeil': <CornerType.kTopLeftCeil: 6>, 'kTopRightCeil': <CornerType.kTopRightCeil: 7>}
        kBottomLeftCeil: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kBottomLeftCeil: 4>
        kBottomLeftFloor: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kBottomLeftFloor: 0>
        kBottomRightCeil: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kBottomRightCeil: 5>
        kBottomRightFloor: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kBottomRightFloor: 1>
        kTopLeftCeil: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kTopLeftCeil: 6>
        kTopLeftFloor: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kTopLeftFloor: 2>
        kTopRightCeil: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kTopRightCeil: 7>
        kTopRightFloor: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kTopRightFloor: 3>
        def __and__(self, other: typing.Any) -> typing.Any:
            ...
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __ge__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __gt__(self, other: typing.Any) -> bool:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __invert__(self) -> typing.Any:
            ...
        def __le__(self, other: typing.Any) -> bool:
            ...
        def __lt__(self, other: typing.Any) -> bool:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __or__(self, other: typing.Any) -> typing.Any:
            ...
        def __rand__(self, other: typing.Any) -> typing.Any:
            ...
        def __repr__(self) -> str:
            ...
        def __ror__(self, other: typing.Any) -> typing.Any:
            ...
        def __rxor__(self, other: typing.Any) -> typing.Any:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        def __xor__(self, other: typing.Any) -> typing.Any:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    kBottomLeftCeil: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kBottomLeftCeil: 4>
    kBottomLeftFloor: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kBottomLeftFloor: 0>
    kBottomRightCeil: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kBottomRightCeil: 5>
    kBottomRightFloor: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kBottomRightFloor: 1>
    kTopLeftCeil: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kTopLeftCeil: 6>
    kTopLeftFloor: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kTopLeftFloor: 2>
    kTopRightCeil: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kTopRightCeil: 7>
    kTopRightFloor: typing.ClassVar[Aabb3Df.CornerType]  # value = <CornerType.kTopRightFloor: 3>
    @staticmethod
    def intersects(*args, **kwargs) -> bool:
        ...
    @typing.overload
    def __contains__(self, point: numpy.ndarray[numpy.float32[3, 1]]) -> bool:
        ...
    @typing.overload
    def __contains__(self, another_aabb: Aabb3Df) -> bool:
        ...
    @typing.overload
    def __init__(self, center: numpy.ndarray[numpy.float32[3, 1]], half_size: float) -> None:
        ...
    @typing.overload
    def __init__(self, min: numpy.ndarray[numpy.float32[3, 1]], max: numpy.ndarray[numpy.float32[3, 1]]) -> None:
        ...
    def corner(self, corner_type: Aabb3Df.CornerType) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @typing.overload
    def padding(self, padding: numpy.ndarray[numpy.float32[3, 1]]) -> Aabb3Df:
        ...
    @typing.overload
    def padding(self, padding: float) -> Aabb3Df:
        ...
    @property
    def center(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def half_sizes(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def max(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def min(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
class AbstractOccupancyOctreeD(AbstractOctreeD):
    def get_hit_occupied_node(self, px: float, py: float, pz: float, vx: float, vy: float, vz: float, ignore_unknown: bool, max_range: float) -> dict:
        ...
    def is_node_at_threshold(self, node: OccupancyOctreeNode) -> bool:
        ...
    def is_node_occupied(self, node: OccupancyOctreeNode) -> bool:
        ...
    def read_binary(self, filename: str) -> bool:
        ...
    def write_binary(self, filename: str, prune_at_first: bool) -> bool:
        ...
class AbstractOccupancyOctreeF(AbstractOctreeF):
    def get_hit_occupied_node(self, px: float, py: float, pz: float, vx: float, vy: float, vz: float, ignore_unknown: bool, max_range: float) -> dict:
        ...
    def is_node_at_threshold(self, node: OccupancyOctreeNode) -> bool:
        ...
    def is_node_occupied(self, node: OccupancyOctreeNode) -> bool:
        ...
    def read_binary(self, filename: str) -> bool:
        ...
    def write_binary(self, filename: str, prune_at_first: bool) -> bool:
        ...
class AbstractOccupancyQuadtreeD(AbstractQuadtreeD):
    def get_hit_occupied_node(self, px: float, py: float, vx: float, vy: float, ignore_unknown: bool, max_range: float) -> dict:
        ...
    def is_node_at_threshold(self, node: OccupancyQuadtreeNode) -> bool:
        ...
    def is_node_occupied(self, node: OccupancyQuadtreeNode) -> bool:
        ...
    def read_binary(self, filename: str) -> bool:
        ...
    def write_binary(self, filename: str, prune_at_first: bool) -> bool:
        ...
class AbstractOccupancyQuadtreeF(AbstractQuadtreeF):
    def get_hit_occupied_node(self, px: float, py: float, vx: float, vy: float, ignore_unknown: bool, max_range: float) -> dict:
        ...
    def is_node_at_threshold(self, node: OccupancyQuadtreeNode) -> bool:
        ...
    def is_node_occupied(self, node: OccupancyQuadtreeNode) -> bool:
        ...
    def read_binary(self, filename: str) -> bool:
        ...
    def write_binary(self, filename: str, prune_at_first: bool) -> bool:
        ...
class AbstractOctreeD:
    class OctreeNodeIterator:
        def get_index_key(self) -> OctreeKey:
            ...
        def get_key(self) -> OctreeKey:
            ...
        def get_node(self) -> AbstractOctreeNode:
            ...
        def next(self) -> None:
            ...
        @property
        def depth(self) -> int:
            ...
        @property
        def is_valid(self) -> bool:
            ...
        @property
        def node_size(self) -> float:
            ...
        @property
        def x(self) -> float:
            ...
        @property
        def y(self) -> float:
            ...
        @property
        def z(self) -> float:
            ...
    def apply_setting(self) -> None:
        ...
    def read(self, filename: str) -> bool:
        ...
    def read_setting(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def search_node(self, x: float, y: float, z: float, max_depth: int) -> AbstractOctreeNode:
        ...
    @typing.overload
    def search_node(self, key: OctreeKey, max_depth: int) -> AbstractOctreeNode:
        ...
    def write(self, filename: str) -> bool:
        ...
    def write_setting(self, arg0: ...) -> None:
        ...
    @property
    def tree_type(self) -> str:
        ...
class AbstractOctreeF:
    class OctreeNodeIterator:
        def get_index_key(self) -> OctreeKey:
            ...
        def get_key(self) -> OctreeKey:
            ...
        def get_node(self) -> AbstractOctreeNode:
            ...
        def next(self) -> None:
            ...
        @property
        def depth(self) -> int:
            ...
        @property
        def is_valid(self) -> bool:
            ...
        @property
        def node_size(self) -> float:
            ...
        @property
        def x(self) -> float:
            ...
        @property
        def y(self) -> float:
            ...
        @property
        def z(self) -> float:
            ...
    def apply_setting(self) -> None:
        ...
    def read(self, filename: str) -> bool:
        ...
    def read_setting(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def search_node(self, x: float, y: float, z: float, max_depth: int) -> AbstractOctreeNode:
        ...
    @typing.overload
    def search_node(self, key: OctreeKey, max_depth: int) -> AbstractOctreeNode:
        ...
    def write(self, filename: str) -> bool:
        ...
    def write_setting(self, arg0: ...) -> None:
        ...
    @property
    def tree_type(self) -> str:
        ...
class AbstractOctreeNode:
    def has_child(self, child_idx: int) -> bool:
        ...
    @property
    def child_index(self) -> int:
        ...
    @property
    def depth(self) -> int:
        ...
    @property
    def has_any_child(self) -> bool:
        ...
    @property
    def node_type(self) -> str:
        ...
    @property
    def num_children(self) -> int:
        ...
class AbstractQuadtreeD:
    class QuadtreeNodeIterator:
        def get_index_key(self) -> QuadtreeKey:
            ...
        def get_key(self) -> QuadtreeKey:
            ...
        def get_node(self) -> AbstractQuadtreeNode:
            ...
        def next(self) -> None:
            ...
        @property
        def depth(self) -> int:
            ...
        @property
        def is_valid(self) -> bool:
            ...
        @property
        def node_size(self) -> float:
            ...
        @property
        def x(self) -> float:
            ...
        @property
        def y(self) -> float:
            ...
    def apply_setting(self) -> None:
        ...
    def read(self, filename: str) -> bool:
        ...
    def read_setting(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def search_node(self, x: float, y: float, max_depth: int) -> AbstractQuadtreeNode:
        ...
    @typing.overload
    def search_node(self, key: QuadtreeKey, max_depth: int) -> AbstractQuadtreeNode:
        ...
    def write(self, filename: str) -> bool:
        ...
    def write_setting(self, arg0: ...) -> None:
        ...
    @property
    def tree_type(self) -> str:
        ...
class AbstractQuadtreeF:
    class QuadtreeNodeIterator:
        def get_index_key(self) -> QuadtreeKey:
            ...
        def get_key(self) -> QuadtreeKey:
            ...
        def get_node(self) -> AbstractQuadtreeNode:
            ...
        def next(self) -> None:
            ...
        @property
        def depth(self) -> int:
            ...
        @property
        def is_valid(self) -> bool:
            ...
        @property
        def node_size(self) -> float:
            ...
        @property
        def x(self) -> float:
            ...
        @property
        def y(self) -> float:
            ...
    def apply_setting(self) -> None:
        ...
    def read(self, filename: str) -> bool:
        ...
    def read_setting(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def search_node(self, x: float, y: float, max_depth: int) -> AbstractQuadtreeNode:
        ...
    @typing.overload
    def search_node(self, key: QuadtreeKey, max_depth: int) -> AbstractQuadtreeNode:
        ...
    def write(self, filename: str) -> bool:
        ...
    def write_setting(self, arg0: ...) -> None:
        ...
    @property
    def tree_type(self) -> str:
        ...
class AbstractQuadtreeNode:
    def has_child(self, child_idx: int) -> bool:
        ...
    @property
    def child_index(self) -> int:
        ...
    @property
    def depth(self) -> int:
        ...
    @property
    def has_any_child(self) -> bool:
        ...
    @property
    def node_type(self) -> str:
        ...
    @property
    def num_children(self) -> int:
        ...
class AxisAlignedRectangle2D(Primitive2D, Aabb2Dd):
    def __init__(self, id: int, center: numpy.ndarray[numpy.float64[2, 1]], half_sizes: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
class Box(Primitive3D):
    center: numpy.ndarray[numpy.float64[3, 1]]
    rotation_matrix: numpy.ndarray[numpy.float64[3, 3]]
    def __init__(self, id: int, center: numpy.ndarray[numpy.float64[3, 1]], half_sizes: numpy.ndarray[numpy.float64[3, 1]], rotation: numpy.ndarray[numpy.float64[3, 3]]) -> None:
        ...
    def rotate(self, rotation: numpy.ndarray[numpy.float64[3, 3]]) -> Box:
        ...
    def translate(self, translation: numpy.ndarray[numpy.float64[3, 1]]) -> Box:
        ...
    @property
    def half_sizes(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class CameraBase3Dd:
    cTo: typing.ClassVar[numpy.ndarray]  # value = array([[ 0.,  0.,  1.,  0.],...
    oTc: typing.ClassVar[numpy.ndarray]  # value = array([[ 0., -1.,  0.,  0.],...
    @staticmethod
    def compute_camera_pose(orientation: numpy.ndarray[numpy.float64[3, 3], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float64[3, 1]]) -> tuple[numpy.ndarray[numpy.float64[3, 3]], numpy.ndarray[numpy.float64[3, 1]]]:
        ...
    @staticmethod
    def compute_extrinsic(camera_orientation: numpy.ndarray[numpy.float64[3, 3], numpy.ndarray.flags.f_contiguous], camera_translation: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[4, 4]]:
        ...
    @staticmethod
    def compute_optical_pose(orientation: numpy.ndarray[numpy.float64[3, 3], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float64[3, 1]]) -> tuple[numpy.ndarray[numpy.float64[3, 3]], numpy.ndarray[numpy.float64[3, 1]]]:
        ...
class CameraBase3Df:
    cTo: typing.ClassVar[numpy.ndarray]  # value = array([[ 0.,  0.,  1.,  0.],...
    oTc: typing.ClassVar[numpy.ndarray]  # value = array([[ 0., -1.,  0.,  0.],...
    @staticmethod
    def compute_camera_pose(orientation: numpy.ndarray[numpy.float32[3, 3], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float32[3, 1]]) -> tuple[numpy.ndarray[numpy.float32[3, 3]], numpy.ndarray[numpy.float32[3, 1]]]:
        ...
    @staticmethod
    def compute_extrinsic(camera_orientation: numpy.ndarray[numpy.float32[3, 3], numpy.ndarray.flags.f_contiguous], camera_translation: numpy.ndarray[numpy.float32[3, 1]]) -> numpy.ndarray[numpy.float32[4, 4]]:
        ...
    @staticmethod
    def compute_optical_pose(orientation: numpy.ndarray[numpy.float32[3, 3], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float32[3, 1]]) -> tuple[numpy.ndarray[numpy.float32[3, 3]], numpy.ndarray[numpy.float32[3, 1]]]:
        ...
class CameraIntrinsicD(YamlableBase):
    camera_cx: float
    camera_cy: float
    camera_fx: float
    camera_fy: float
    image_height: int
    image_width: int
    def __init__(self) -> None:
        ...
    def compute_frame_direction(self, u: int, v: int) -> tuple[float, float, float]:
        ...
    def compute_frame_directions(self) -> numpy.ndarray[numpy.float64]:
        ...
    def convert_depth_to_distance(self, depth: numpy.ndarray[numpy.float64[m, n]], rgb: Mat, optical_pose: numpy.ndarray[numpy.float64[4, 4]] | None = None) -> dict:
        ...
    def resize(self, factor: float) -> tuple[int, int]:
        ...
    @property
    def matrix(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
class CameraIntrinsicF(YamlableBase):
    camera_cx: float
    camera_cy: float
    camera_fx: float
    camera_fy: float
    image_height: int
    image_width: int
    def __init__(self) -> None:
        ...
    def compute_frame_direction(self, u: int, v: int) -> tuple[float, float, float]:
        ...
    def compute_frame_directions(self) -> numpy.ndarray[numpy.float32]:
        ...
    def convert_depth_to_distance(self, depth: numpy.ndarray[numpy.float32[m, n]], rgb: Mat, optical_pose: numpy.ndarray[numpy.float32[4, 4]] | None = None) -> dict:
        ...
    def resize(self, factor: float) -> tuple[int, int]:
        ...
    @property
    def matrix(self) -> numpy.ndarray[numpy.float32[3, 3]]:
        ...
class CityStreetMap:
    class Scene:
        bucket: int
        goal_x: int
        goal_y: int
        map: str
        map_height: int
        map_width: int
        optimal_length: float
        start_x: int
        start_y: int
    kFree: typing.ClassVar[int] = 0
    kObstacle: typing.ClassVar[int] = 255
    kOutOfBoundAt: typing.ClassVar[str] = '@'
    kOutOfBoundO: typing.ClassVar[str] = 'O'
    kPassableDot: typing.ClassVar[str] = '.'
    kPassableG: typing.ClassVar[str] = 'G'
    kSwamp: typing.ClassVar[str] = 'S'
    kTree: typing.ClassVar[str] = 'T'
    kWater: typing.ClassVar[str] = 'W'
    @staticmethod
    def load_map(filename: str) -> Mat:
        ...
    @staticmethod
    def load_scenes(filename: str) -> list[...]:
        ...
class DepthCamera3Dd(CameraBase3Dd, RangeSensor3Dd):
    @staticmethod
    def Setting() -> CameraIntrinsicD:
        ...
    def __init__(self, setting: CameraIntrinsicD) -> None:
        ...
    @property
    def setting(self) -> CameraIntrinsicD:
        ...
class DepthCamera3Df(CameraBase3Df, RangeSensor3Df):
    @staticmethod
    def Setting() -> CameraIntrinsicF:
        ...
    def __init__(self, setting: CameraIntrinsicF) -> None:
        ...
    @property
    def setting(self) -> CameraIntrinsicF:
        ...
class DepthFrame3Dd(RangeSensorFrame3Dd):
    class Setting(RangeSensorFrame3Dd.Setting):
        camera_intrinsic: CameraIntrinsicD
        def __init__(self) -> None:
            ...
    @staticmethod
    def depth_image_to_depth(depth_image: numpy.ndarray[numpy.float64[m, n]], depth_scale: float) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @staticmethod
    def depth_to_depth_image(depth: numpy.ndarray[numpy.float64[m, n]], depth_scale: float) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def __init__(self, setting: DepthFrame3Dd.Setting) -> None:
        ...
    def reset(self) -> None:
        ...
    @typing.overload
    def update_ranges(self, rotation: numpy.ndarray[numpy.float64[3, 3], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float64[3, 1]], depth: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    @typing.overload
    def update_ranges(self, rotation: numpy.ndarray[numpy.float64[3, 3], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float64[3, 1]], depth_file: str, depth_scale: float) -> None:
        ...
    @property
    def image_height(self) -> int:
        ...
    @property
    def image_width(self) -> int:
        ...
    @property
    def setting(self) -> DepthFrame3Dd.Setting:
        ...
class DepthFrame3Df(RangeSensorFrame3Df):
    class Setting(RangeSensorFrame3Df.Setting):
        camera_intrinsic: CameraIntrinsicF
        def __init__(self) -> None:
            ...
    @staticmethod
    def depth_image_to_depth(depth_image: numpy.ndarray[numpy.float32[m, n]], depth_scale: float) -> numpy.ndarray[numpy.float32[m, n]]:
        ...
    @staticmethod
    def depth_to_depth_image(depth: numpy.ndarray[numpy.float32[m, n]], depth_scale: float) -> numpy.ndarray[numpy.float32[m, n]]:
        ...
    def __init__(self, setting: DepthFrame3Df.Setting) -> None:
        ...
    def reset(self) -> None:
        ...
    @typing.overload
    def update_ranges(self, rotation: numpy.ndarray[numpy.float32[3, 3], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float32[3, 1]], depth: numpy.ndarray[numpy.float32[m, n]]) -> None:
        ...
    @typing.overload
    def update_ranges(self, rotation: numpy.ndarray[numpy.float32[3, 3], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float32[3, 1]], depth_file: str, depth_scale: float) -> None:
        ...
    @property
    def image_height(self) -> int:
        ...
    @property
    def image_width(self) -> int:
        ...
    @property
    def setting(self) -> DepthFrame3Df.Setting:
        ...
class Ellipse2D(Primitive2D):
    center: numpy.ndarray[numpy.float64[2, 1]]
    orientation_angle: float
    def __init__(self, id: int, center: numpy.ndarray[numpy.float64[2, 1]], a: float, b: float, angle: float) -> None:
        ...
    def compute_points_on_boundary(self, num_points: int, start_angle: float, end_angle: float) -> list[numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    def rotate(self, angle: float) -> Ellipse2D:
        ...
    def translate(self, translation: numpy.ndarray[numpy.float64[2, 1]]) -> Ellipse2D:
        ...
    @property
    def radii(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def rotation_matrix(self) -> numpy.ndarray[numpy.float64[2, 2]]:
        ...
class Ellipsoid(Primitive3D):
    center: numpy.ndarray[numpy.float64[3, 1]]
    rotation_matrix: numpy.ndarray[numpy.float64[3, 3]]
    def __init__(self, id: int, center: numpy.ndarray[numpy.float64[3, 1]], radius: numpy.ndarray[numpy.float64[3, 1]], rotation: numpy.ndarray[numpy.float64[3, 3]]) -> None:
        ...
    def rotate(self, rotation: numpy.ndarray[numpy.float64[3, 3]]) -> Ellipsoid:
        ...
    def translate(self, translation: numpy.ndarray[numpy.float64[3, 1]]) -> Ellipsoid:
        ...
    @property
    def radii(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class HouseExpoMap:
    @typing.overload
    def __init__(self, file: str) -> None:
        ...
    @typing.overload
    def __init__(self, file: str, wall_thickness: float) -> None:
        ...
    def extrude_to_3d(self, room_height: float, filename: str) -> None:
        ...
    def to_json(self) -> str:
        ...
    @property
    def file(self) -> str:
        ...
    @property
    def meter_space(self) -> Space2D:
        ...
    @property
    def room_id(self) -> str:
        ...
class Lidar2D:
    class Mode:
        """
        Mode of directed distance.
        
        Members:
        
          kDdf : Compute unsigned directed distance.
        
          kSddfV1 : Compute signed directed distance, version 1.
        
          kSddfV2 : Compute signed directed distance, version 2.
        """
        __members__: typing.ClassVar[dict[str, Lidar2D.Mode]]  # value = {'kDdf': <Mode.kDdf: 0>, 'kSddfV1': <Mode.kSddfV1: 1>, 'kSddfV2': <Mode.kSddfV2: 2>}
        kDdf: typing.ClassVar[Lidar2D.Mode]  # value = <Mode.kDdf: 0>
        kSddfV1: typing.ClassVar[Lidar2D.Mode]  # value = <Mode.kSddfV1: 1>
        kSddfV2: typing.ClassVar[Lidar2D.Mode]  # value = <Mode.kSddfV2: 2>
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __ge__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __gt__(self, other: typing.Any) -> bool:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __le__(self, other: typing.Any) -> bool:
            ...
        def __lt__(self, other: typing.Any) -> bool:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class Setting(YamlableBase):
        max_angle: float
        min_angle: float
        mode: Lidar2D.Mode
        num_lines: int
        sign_method: Space2D.SignMethod
        def __init__(self) -> None:
            ...
    kDdf: typing.ClassVar[Lidar2D.Mode]  # value = <Mode.kDdf: 0>
    kSddfV1: typing.ClassVar[Lidar2D.Mode]  # value = <Mode.kSddfV1: 1>
    kSddfV2: typing.ClassVar[Lidar2D.Mode]  # value = <Mode.kSddfV2: 2>
    def __init__(self, setting: Lidar2D.Setting, space2d: Space2D) -> None:
        ...
    @typing.overload
    def scan(self, rotation_angle: float, translation: numpy.ndarray[numpy.float64[2, 1]], parallel: bool = False) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def scan(self, rotation: numpy.ndarray[numpy.float64[2, 2], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float64[2, 1]], parallel: bool = False) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def scan_multi_poses(self, poses: list[numpy.ndarray[numpy.float64[3, 3]]], parallel: bool = False) -> list[numpy.ndarray[numpy.float64[m, 1]]]:
        ...
    @property
    def angles(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @property
    def ray_directions_in_frame(self) -> numpy.ndarray[numpy.float64[2, n]]:
        ...
    @property
    def setting(self) -> Lidar2D.Setting:
        ...
class Lidar3Dd(RangeSensor3Dd):
    class Setting(YamlableBase):
        azimuth_max: float
        azimuth_min: float
        elevation_max: float
        elevation_min: float
        num_azimuth_lines: int
        num_elevation_lines: int
        def __init__(self) -> None:
            ...
    def __init__(self, setting: Lidar3Dd.Setting) -> None:
        ...
    @property
    def azimuth_angles(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @property
    def elevation_angles(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @property
    def setting(self) -> Lidar3Dd.Setting:
        ...
class Lidar3Df(RangeSensor3Df):
    class Setting(YamlableBase):
        azimuth_max: float
        azimuth_min: float
        elevation_max: float
        elevation_min: float
        num_azimuth_lines: int
        num_elevation_lines: int
        def __init__(self) -> None:
            ...
    def __init__(self, setting: Lidar3Df.Setting) -> None:
        ...
    @property
    def azimuth_angles(self) -> numpy.ndarray[numpy.float32[m, 1]]:
        ...
    @property
    def elevation_angles(self) -> numpy.ndarray[numpy.float32[m, 1]]:
        ...
    @property
    def setting(self) -> Lidar3Df.Setting:
        ...
class LidarFrame2Dd:
    class Partition:
        def angle_in_partition(self, angle_world: float) -> bool:
            ...
        @property
        def index_begin(self) -> int:
            ...
        @property
        def index_end(self) -> int:
            ...
    class Setting(YamlableBase):
        angle_max: float
        angle_min: float
        discontinuity_factor: float
        min_partition_size: int
        num_rays: int
        rolling_diff_discount: float
        valid_range_max: float
        valid_range_min: float
        def __init__(self) -> None:
            ...
    def __init__(self, setting: LidarFrame2Dd.Setting) -> None:
        ...
    def compute_closest_end_point(self, position: numpy.ndarray[numpy.float64[2, 1]]) -> dict:
        ...
    def compute_rays_at(self, position_world: numpy.ndarray[numpy.float64[2, 1]]) -> dict:
        ...
    def coords_is_in_frame(self, angle_frame: float) -> bool:
        ...
    def dir_frame_to_world(self, dir_frame: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def dir_world_to_frame(self, dir_world: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def pos_frame_to_world(self, xy_frame: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def pos_world_to_frame(self, xy_world: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def position_is_in_frame(self, xy_frame: numpy.ndarray[numpy.float64[2, 1]]) -> bool:
        ...
    @typing.overload
    def sample_along_rays(self, num_samples_per_ray: int, max_in_obstacle_dist: float, sampled_rays_ratio: float) -> dict:
        ...
    @typing.overload
    def sample_along_rays(self, range_step: float, max_in_obstacle_dist: float, sampled_rays_ratio: float) -> dict:
        ...
    def sample_in_region(self, num_positions: int, num_along_ray_samples_per_ray: int, num_near_surface_samples_per_ray: int, max_in_obstacle_dist: float) -> dict:
        ...
    def sample_near_surface(self, num_samples_per_ray: int, max_offset: float, sampled_rays_ratio: float) -> dict:
        ...
    def update_ranges(self, rotation: numpy.ndarray[numpy.float64[2, 2], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float64[2, 1]], ranges: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @property
    def angles_in_frame(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @property
    def angles_in_world(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @property
    def end_points_in_frame(self) -> list[numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    @property
    def end_points_in_world(self) -> list[numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    @property
    def hit_points_world(self) -> list[numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    @property
    def hit_ray_indices(self) -> list[int]:
        ...
    @property
    def is_partitioned(self) -> bool:
        ...
    @property
    def is_valid(self) -> bool:
        ...
    @property
    def max_valid_range(self) -> float:
        ...
    @property
    def min_valid_range(self) -> float:
        ...
    @property
    def num_hit_rays(self) -> int:
        ...
    @property
    def num_rays(self) -> int:
        ...
    @property
    def partitions(self) -> list[LidarFrame2Dd.Partition]:
        ...
    @property
    def pose_matrix(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @property
    def ranges(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @property
    def ray_directions_in_frame(self) -> list[numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    @property
    def ray_directions_in_world(self) -> list[numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    @property
    def rotation_angle(self) -> float:
        ...
    @property
    def rotation_matrix(self) -> numpy.ndarray[numpy.float64[2, 2]]:
        ...
    @property
    def setting(self) -> LidarFrame2Dd.Setting:
        ...
    @property
    def translation_vector(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class LidarFrame2Df:
    class Partition:
        def angle_in_partition(self, angle_world: float) -> bool:
            ...
        @property
        def index_begin(self) -> int:
            ...
        @property
        def index_end(self) -> int:
            ...
    class Setting(YamlableBase):
        angle_max: float
        angle_min: float
        discontinuity_factor: float
        min_partition_size: int
        num_rays: int
        rolling_diff_discount: float
        valid_range_max: float
        valid_range_min: float
        def __init__(self) -> None:
            ...
    def __init__(self, setting: LidarFrame2Df.Setting) -> None:
        ...
    def compute_closest_end_point(self, position: numpy.ndarray[numpy.float32[2, 1]]) -> dict:
        ...
    def compute_rays_at(self, position_world: numpy.ndarray[numpy.float32[2, 1]]) -> dict:
        ...
    def coords_is_in_frame(self, angle_frame: float) -> bool:
        ...
    def dir_frame_to_world(self, dir_frame: numpy.ndarray[numpy.float32[2, 1]]) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    def dir_world_to_frame(self, dir_world: numpy.ndarray[numpy.float32[2, 1]]) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    def pos_frame_to_world(self, xy_frame: numpy.ndarray[numpy.float32[2, 1]]) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    def pos_world_to_frame(self, xy_world: numpy.ndarray[numpy.float32[2, 1]]) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    def position_is_in_frame(self, xy_frame: numpy.ndarray[numpy.float32[2, 1]]) -> bool:
        ...
    @typing.overload
    def sample_along_rays(self, num_samples_per_ray: int, max_in_obstacle_dist: float, sampled_rays_ratio: float) -> dict:
        ...
    @typing.overload
    def sample_along_rays(self, range_step: float, max_in_obstacle_dist: float, sampled_rays_ratio: float) -> dict:
        ...
    def sample_in_region(self, num_positions: int, num_along_ray_samples_per_ray: int, num_near_surface_samples_per_ray: int, max_in_obstacle_dist: float) -> dict:
        ...
    def sample_near_surface(self, num_samples_per_ray: int, max_offset: float, sampled_rays_ratio: float) -> dict:
        ...
    def update_ranges(self, rotation: numpy.ndarray[numpy.float32[2, 2], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float32[2, 1]], ranges: numpy.ndarray[numpy.float32[m, 1]]) -> None:
        ...
    @property
    def angles_in_frame(self) -> numpy.ndarray[numpy.float32[m, 1]]:
        ...
    @property
    def angles_in_world(self) -> numpy.ndarray[numpy.float32[m, 1]]:
        ...
    @property
    def end_points_in_frame(self) -> list[numpy.ndarray[numpy.float32[2, 1]]]:
        ...
    @property
    def end_points_in_world(self) -> list[numpy.ndarray[numpy.float32[2, 1]]]:
        ...
    @property
    def hit_points_world(self) -> list[numpy.ndarray[numpy.float32[2, 1]]]:
        ...
    @property
    def hit_ray_indices(self) -> list[int]:
        ...
    @property
    def is_partitioned(self) -> bool:
        ...
    @property
    def is_valid(self) -> bool:
        ...
    @property
    def max_valid_range(self) -> float:
        ...
    @property
    def min_valid_range(self) -> float:
        ...
    @property
    def num_hit_rays(self) -> int:
        ...
    @property
    def num_rays(self) -> int:
        ...
    @property
    def partitions(self) -> list[LidarFrame2Df.Partition]:
        ...
    @property
    def pose_matrix(self) -> numpy.ndarray[numpy.float32[3, 3]]:
        ...
    @property
    def ranges(self) -> numpy.ndarray[numpy.float32[m, 1]]:
        ...
    @property
    def ray_directions_in_frame(self) -> list[numpy.ndarray[numpy.float32[2, 1]]]:
        ...
    @property
    def ray_directions_in_world(self) -> list[numpy.ndarray[numpy.float32[2, 1]]]:
        ...
    @property
    def rotation_angle(self) -> float:
        ...
    @property
    def rotation_matrix(self) -> numpy.ndarray[numpy.float32[2, 2]]:
        ...
    @property
    def setting(self) -> LidarFrame2Df.Setting:
        ...
    @property
    def translation_vector(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
class LidarFrame3Dd(RangeSensorFrame3Dd):
    class Setting(RangeSensorFrame3Dd.Setting):
        azimuth_max: float
        azimuth_min: float
        elevation_max: float
        elevation_min: float
        num_azimuth_lines: int
        num_elevation_lines: int
        def __init__(self) -> None:
            ...
    def __init__(self, setting: LidarFrame3Dd.Setting) -> None:
        ...
    def reset(self) -> None:
        ...
    def update_ranges(self, rotation: numpy.ndarray[numpy.float64[3, 3], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float64[3, 1]], ranges: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    @property
    def num_azimuth_lines(self) -> int:
        ...
    @property
    def num_elevation_lines(self) -> int:
        ...
    @property
    def setting(self) -> LidarFrame3Dd.Setting:
        ...
class LidarFrame3Df(RangeSensorFrame3Df):
    class Setting(RangeSensorFrame3Df.Setting):
        azimuth_max: float
        azimuth_min: float
        elevation_max: float
        elevation_min: float
        num_azimuth_lines: int
        num_elevation_lines: int
        def __init__(self) -> None:
            ...
    def __init__(self, setting: LidarFrame3Df.Setting) -> None:
        ...
    def reset(self) -> None:
        ...
    def update_ranges(self, rotation: numpy.ndarray[numpy.float32[3, 3], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float32[3, 1]], ranges: numpy.ndarray[numpy.float32[m, n]]) -> None:
        ...
    @property
    def num_azimuth_lines(self) -> int:
        ...
    @property
    def num_elevation_lines(self) -> int:
        ...
    @property
    def setting(self) -> LidarFrame3Df.Setting:
        ...
class Line2D(Primitive2D):
    p0: numpy.ndarray[numpy.float64[2, 1]]
    p1: numpy.ndarray[numpy.float64[2, 1]]
    def __init__(self, id: int, p0: numpy.ndarray[numpy.float64[2, 1]], p1: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
class LogOddMap:
    class CellType:
        """
        Type of grid cell.
        
        Members:
        
          kOccupied
        
          kUnexplored
        
          kFree
        """
        __members__: typing.ClassVar[dict[str, LogOddMap.CellType]]  # value = {'kOccupied': <CellType.kOccupied: 0>, 'kUnexplored': <CellType.kUnexplored: 128>, 'kFree': <CellType.kFree: 255>}
        kFree: typing.ClassVar[LogOddMap.CellType]  # value = <CellType.kFree: 255>
        kOccupied: typing.ClassVar[LogOddMap.CellType]  # value = <CellType.kOccupied: 0>
        kUnexplored: typing.ClassVar[LogOddMap.CellType]  # value = <CellType.kUnexplored: 128>
        def __and__(self, other: typing.Any) -> typing.Any:
            ...
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __ge__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __gt__(self, other: typing.Any) -> bool:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __invert__(self) -> typing.Any:
            ...
        def __le__(self, other: typing.Any) -> bool:
            ...
        def __lt__(self, other: typing.Any) -> bool:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __or__(self, other: typing.Any) -> typing.Any:
            ...
        def __rand__(self, other: typing.Any) -> typing.Any:
            ...
        def __repr__(self) -> str:
            ...
        def __ror__(self, other: typing.Any) -> typing.Any:
            ...
        def __rxor__(self, other: typing.Any) -> typing.Any:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        def __xor__(self, other: typing.Any) -> typing.Any:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    kFree: typing.ClassVar[LogOddMap.CellType]  # value = <CellType.kFree: 255>
    kOccupied: typing.ClassVar[LogOddMap.CellType]  # value = <CellType.kOccupied: 0>
    kUnexplored: typing.ClassVar[LogOddMap.CellType]  # value = <CellType.kUnexplored: 128>
class LogOddMap2Dd:
    class Setting(YamlableBase):
        filter_obstacles_in_cleaned_mask: bool
        max_log_odd: float
        measurement_certainty: float
        min_log_odd: float
        num_iters_for_cleaned_mask: int
        sensor_max_range: float
        sensor_min_range: float
        threshold_free: float
        threshold_occupied: float
        use_cross_kernel: bool
        def __init__(self) -> None:
            ...
    @staticmethod
    @typing.overload
    def __init__(*args, **kwargs) -> None:
        ...
    @staticmethod
    @typing.overload
    def __init__(*args, **kwargs) -> None:
        ...
    @staticmethod
    def get_cell_type_from_name(cell_type_name: str) -> LogOddMap.CellType:
        ...
    @staticmethod
    def get_cell_type_name(cell_type: LogOddMap.CellType) -> str:
        ...
    def compute_statistics_of_lidar_frame(self, position: numpy.ndarray[numpy.float64[2, 1]], theta: float, angles_body: numpy.ndarray[numpy.float64[m, 1]], ranges: numpy.ndarray[numpy.float64[m, 1]], clip_ranges: bool) -> tuple[int, int, int, int]:
        ...
    def get_frontiers(self, clean_at_first: bool = True, approx_iters: int = 4) -> list[numpy.ndarray[numpy.int32[2, n]]]:
        ...
    def load_external_possibility_map(self, position: numpy.ndarray[numpy.float64[2, 1]], theta: float, possibility_map: numpy.ndarray[numpy.int32[m, n], numpy.ndarray.flags.f_contiguous]) -> None:
        ...
    def update(self, position: numpy.ndarray[numpy.float64[2, 1]], theta: float, angles_body: numpy.ndarray[numpy.float64[m, 1]], ranges: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @property
    def cleaned_free_mask(self) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def cleaned_occupied_mask(self) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def cleaned_unexplored_mask(self) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def free_mask(self) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def log_map(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @property
    def num_free_cells(self) -> int:
        ...
    @property
    def num_occupied_cells(self) -> int:
        ...
    @property
    def num_unexplored_cells(self) -> int:
        ...
    @property
    def occupancy_map(self) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def occupied_mask(self) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def possibility_map(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @property
    def setting(self) -> LogOddMap2Dd.Setting:
        ...
    @property
    def unexplored_mask(self) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
class LogOddMap2Df:
    class Setting(YamlableBase):
        filter_obstacles_in_cleaned_mask: bool
        max_log_odd: float
        measurement_certainty: float
        min_log_odd: float
        num_iters_for_cleaned_mask: int
        sensor_max_range: float
        sensor_min_range: float
        threshold_free: float
        threshold_occupied: float
        use_cross_kernel: bool
        def __init__(self) -> None:
            ...
    @staticmethod
    @typing.overload
    def __init__(*args, **kwargs) -> None:
        ...
    @staticmethod
    @typing.overload
    def __init__(*args, **kwargs) -> None:
        ...
    @staticmethod
    def get_cell_type_from_name(cell_type_name: str) -> LogOddMap.CellType:
        ...
    @staticmethod
    def get_cell_type_name(cell_type: LogOddMap.CellType) -> str:
        ...
    def compute_statistics_of_lidar_frame(self, position: numpy.ndarray[numpy.float32[2, 1]], theta: float, angles_body: numpy.ndarray[numpy.float32[m, 1]], ranges: numpy.ndarray[numpy.float32[m, 1]], clip_ranges: bool) -> tuple[int, int, int, int]:
        ...
    def get_frontiers(self, clean_at_first: bool = True, approx_iters: int = 4) -> list[numpy.ndarray[numpy.int32[2, n]]]:
        ...
    def load_external_possibility_map(self, position: numpy.ndarray[numpy.float32[2, 1]], theta: float, possibility_map: numpy.ndarray[numpy.int32[m, n], numpy.ndarray.flags.f_contiguous]) -> None:
        ...
    def update(self, position: numpy.ndarray[numpy.float32[2, 1]], theta: float, angles_body: numpy.ndarray[numpy.float32[m, 1]], ranges: numpy.ndarray[numpy.float32[m, 1]]) -> None:
        ...
    @property
    def cleaned_free_mask(self) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def cleaned_occupied_mask(self) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def cleaned_unexplored_mask(self) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def free_mask(self) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def log_map(self) -> numpy.ndarray[numpy.float32[m, n]]:
        ...
    @property
    def num_free_cells(self) -> int:
        ...
    @property
    def num_occupied_cells(self) -> int:
        ...
    @property
    def num_unexplored_cells(self) -> int:
        ...
    @property
    def occupancy_map(self) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def occupied_mask(self) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def possibility_map(self) -> numpy.ndarray[numpy.float32[m, n]]:
        ...
    @property
    def setting(self) -> LogOddMap2Df.Setting:
        ...
    @property
    def unexplored_mask(self) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
class MarchingCubes:
    class ValidCube:
        cfg_index: int
        coords: numpy.ndarray[numpy.int32[3, 1]]
        edges: list[numpy.ndarray[numpy.int32[3, 1]]]
        def __init__(self) -> None:
            ...
    @staticmethod
    def calculate_cube_cfg_index(vertex_values: numpy.ndarray[numpy.float64[8, 1]], iso_value: float) -> int:
        ...
    @staticmethod
    def collect_valid_cubes(grid_shape: numpy.ndarray[numpy.int32[3, 1]], grid_values: numpy.ndarray[numpy.float64[m, 1]], mask: numpy.ndarray[bool[m, 1]] | None = None, iso_value: float = 0.0, row_major: bool = True, parallel: bool = False) -> tuple[numpy.ndarray[numpy.int32[3, n]], numpy.ndarray[numpy.int32[m, 1]], numpy.ndarray[numpy.int32[2, n]], numpy.ndarray[numpy.int32[3, n]]]:
        ...
    @staticmethod
    def get_vertex_offsets() -> numpy.ndarray[numpy.int32]:
        ...
    @staticmethod
    def process_valid_cubes(cube_coords: numpy.ndarray[numpy.int32[3, n]], cube_config_indices: numpy.ndarray[numpy.int32[m, 1]], cube_edge_indices: numpy.ndarray[numpy.int32[2, n]], edge_coords: numpy.ndarray[numpy.int32[3, n]], coords_min: numpy.ndarray[numpy.float64[3, 1]], grid_res: numpy.ndarray[numpy.float64[3, 1]], grid_shape: numpy.ndarray[numpy.int32[3, 1]], grid_values: numpy.ndarray[numpy.float64[m, 1]], iso_value: float, row_major: bool = True, parallel: bool = False) -> tuple[numpy.ndarray[numpy.float64[3, n]], numpy.ndarray[numpy.int32[3, n]], numpy.ndarray[numpy.float64[3, n]]]:
        ...
    @staticmethod
    def run(coords_min: numpy.ndarray[numpy.float64[3, 1]], grid_res: numpy.ndarray[numpy.float64[3, 1]], grid_shape: numpy.ndarray[numpy.int32[3, 1]], grid_values: numpy.ndarray[numpy.float64[m, 1]], mask: numpy.ndarray[bool[m, 1]] | None = None, iso_value: float = 0.0, row_major: bool = True, parallel: bool = False) -> tuple[numpy.ndarray[numpy.float64[3, n]], numpy.ndarray[numpy.int32[3, n]], numpy.ndarray[numpy.float64[3, n]]]:
        ...
    @staticmethod
    def single_cube(vertex_coords: numpy.ndarray[numpy.float64[3, 8], numpy.ndarray.flags.f_contiguous], grid_values: numpy.ndarray[numpy.float64[8, 1]], iso_value: float) -> tuple:
        ...
    def __init__(self) -> None:
        ...
class MeshSdf:
    def __call__(self, points: numpy.ndarray[numpy.float64[3, n]], trunc_aabb: bool = False, n_threads: int = 32) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def __init__(self, verts: list[numpy.ndarray[numpy.float64[3, 1]]], faces: list[numpy.ndarray[numpy.int32[3, 1]]], use_open3d: bool = True, robust: bool = True) -> None:
        ...
class NdTreeSetting(YamlableBase):
    __hash__: typing.ClassVar[None] = None
    resolution: float
    tree_depth: int
    def __eq__(self, other: NdTreeSetting) -> bool:
        ...
    def __init__(self) -> None:
        ...
    def __ne__(self, other: NdTreeSetting) -> bool:
        ...
class OccupancyNdTreeSetting(NdTreeSetting):
    log_odd_hit: float
    log_odd_max: float
    log_odd_min: float
    log_odd_miss: float
    log_odd_occ_threshold: float
    probability_hit: float
    probability_miss: float
    probability_occupied_threshold: float
    def __init__(self) -> None:
        ...
class OccupancyOctreeBaseSetting(OccupancyNdTreeSetting):
    aabb: Aabb3Dd
    use_aabb_limit: bool
    use_change_detection: bool
    def __init__(self) -> None:
        ...
class OccupancyOctreeD(AbstractOccupancyOctreeD):
    class BatchRayCaster:
        def step(self, max_depth: numpy.ndarray[bool[m, 1]] = 0) -> OccupancyOctreeD.BatchRayCaster:
            ...
        @property
        def ever_hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def frontier_keys(self) -> list[OctreeKey]:
            ...
        @property
        def frontier_nodes(self) -> list[OccupancyOctreeNode]:
            ...
        @property
        def frontier_ray_indices(self) -> list[list[int]]:
            ...
        @property
        def hit_distances(self) -> numpy.ndarray[numpy.float64[m, 1]]:
            ...
        @property
        def hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def hit_nodes(self) -> list[OccupancyOctreeNode]:
            ...
        @property
        def hit_positions(self) -> list[numpy.ndarray[numpy.float64[3, 1]]]:
            ...
        @property
        def num_rays(self) -> int:
            ...
        @property
        def ray_directions(self) -> numpy.ndarray[numpy.float64[3, n]]:
            ...
        @property
        def ray_origins(self) -> numpy.ndarray[numpy.float64[3, n]]:
            ...
    class BottomLeafNeighborIterator(OccupancyOctreeD.IteratorBase):
        pass
    class Drawer:
        @staticmethod
        def Setting() -> OccupancyOctreeDrawerSetting:
            ...
        def __init__(self, setting: OccupancyOctreeDrawerSetting, octree: OccupancyOctreeD = None) -> None:
            ...
        @typing.overload
        def draw_leaves(self) -> list[...]:
            ...
        @typing.overload
        def draw_leaves(self, filename: str) -> None:
            ...
        @typing.overload
        def draw_tree(self) -> list[...]:
            ...
        @typing.overload
        def draw_tree(self, filename: str) -> None:
            ...
        def set_draw_leaf_callback(self, callback: typing.Callable[[OccupancyOctreeD.Drawer, list[...], OccupancyOctreeD.LeafInAabbIterator], None]) -> None:
            ...
        def set_draw_tree_callback(self, callback: typing.Callable[[OccupancyOctreeD.Drawer, list[...], OccupancyOctreeD.TreeInAabbIterator], None]) -> None:
            ...
        @property
        def setting(self) -> OccupancyOctreeDrawerSetting:
            ...
    class EastLeafNeighborIterator(OccupancyOctreeD.IteratorBase):
        pass
    class IteratorBase(AbstractOctreeD.OctreeNodeIterator):
        __hash__: typing.ClassVar[None] = None
        def __eq__(self, arg0: OccupancyOctreeD.IteratorBase) -> bool:
            ...
        def __ne__(self, arg0: OccupancyOctreeD.IteratorBase) -> bool:
            ...
        @property
        def index_key(self) -> OctreeKey:
            ...
        @property
        def key(self) -> OctreeKey:
            ...
        @property
        def node(self) -> OccupancyOctreeNode:
            ...
        @property
        def node_aabb(self) -> Aabb3Dd:
            ...
    class LeafInAabbIterator(OccupancyOctreeD.IteratorBase):
        pass
    class LeafIterator(OccupancyOctreeD.IteratorBase):
        pass
    class LeafOfNodeIterator(OccupancyOctreeD.IteratorBase):
        pass
    class NodeOnRayIterator(OccupancyOctreeD.IteratorBase):
        @property
        def distance(self) -> float:
            ...
    class NorthLeafNeighborIterator(OccupancyOctreeD.IteratorBase):
        pass
    class SouthLeafNeighborIterator(OccupancyOctreeD.IteratorBase):
        pass
    class TopLeafNeighborIterator(OccupancyOctreeD.IteratorBase):
        pass
    class TreeInAabbIterator(OccupancyOctreeD.IteratorBase):
        pass
    class TreeIterator(OccupancyOctreeD.IteratorBase):
        pass
    class WestLeafNeighborIterator(OccupancyOctreeD.IteratorBase):
        pass
    @staticmethod
    def Setting() -> OccupancyOctreeBaseSetting:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, setting: OccupancyOctreeBaseSetting) -> None:
        ...
    @typing.overload
    def __init__(self, filename: str) -> None:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: int, depth: int) -> int:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: OctreeKey, depth: int) -> OctreeKey:
        ...
    def cast_ray(self, px: float, py: float, pz: float, vx: float, vy: float, vz: float, ignore_unknown: bool, max_range: float) -> dict:
        ...
    @typing.overload
    def cast_rays(self, position: numpy.ndarray[numpy.float64[3, 1]], rotation: numpy.ndarray[numpy.float64[3, 3], numpy.ndarray.flags.f_contiguous], azimuth_angles: numpy.ndarray[numpy.float64[m, 1]], elevation_angles: numpy.ndarray[numpy.float64[m, 1]], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    @typing.overload
    def cast_rays(self, positions: numpy.ndarray[numpy.float64[3, n], numpy.ndarray.flags.f_contiguous], directions: numpy.ndarray[numpy.float64[3, n], numpy.ndarray.flags.f_contiguous], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    def clear(self) -> None:
        ...
    def compute_bottom_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_common_ancestor_key(self, arg0: OctreeKey, arg1: OctreeKey) -> tuple[OctreeKey, int]:
        ...
    def compute_east_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_north_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_ray_coords(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float) -> list[numpy.ndarray[numpy.float64[3, 1]]] | None:
        ...
    def compute_ray_keys(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float) -> list[OctreeKey] | None:
        ...
    def compute_south_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_top_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_west_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float) -> int:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float, depth: int) -> int:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, z: float) -> OctreeKey:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, z: float, depth: int) -> OctreeKey:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float, depth: int) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, z: float) -> OctreeKey | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, z: float, depth: int) -> OctreeKey | None:
        ...
    def create_node_child(self, node: OccupancyOctreeNode, child_idx: int) -> OccupancyOctreeNode:
        ...
    @typing.overload
    def delete_node(self, x: float, y: float, z: float, depth: int) -> int:
        ...
    @typing.overload
    def delete_node(self, key: OctreeKey, depth: int) -> None:
        ...
    def delete_node_child(self, node: OccupancyOctreeNode, child_idx: int, key: OctreeKey) -> int:
        ...
    def expand(self) -> None:
        ...
    def expand_node(self, node: OccupancyOctreeNode) -> None:
        ...
    def get_batch_ray_caster(self, origins: numpy.ndarray[numpy.float64[3, n]], directions: numpy.ndarray[numpy.float64[3, n]], max_ranges: numpy.ndarray[numpy.float64[m, 1]] = ..., node_paddings: numpy.ndarray[numpy.float64[m, 1]] = ..., bidirectional_flags: numpy.ndarray[bool[m, 1]] = ..., leaf_only_flags: numpy.ndarray[bool[m, 1]] = ..., min_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ..., max_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ...) -> ...:
        ...
    def get_node_child(self, node: OccupancyOctreeNode, child_idx: int) -> OccupancyOctreeNode:
        ...
    def get_node_size(self, depth: int) -> float:
        ...
    @typing.overload
    def insert_node(self, x: float, y: float, z: float, depth: int) -> OccupancyOctreeNode:
        ...
    @typing.overload
    def insert_node(self, key: OctreeKey, depth: int) -> OccupancyOctreeNode:
        ...
    def insert_point_cloud(self, points: numpy.ndarray[numpy.float64[3, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float64[3, 1]], min_range: float, max_range: float, with_count: bool, parallel: bool, lazy_eval: bool, discrete: bool) -> None:
        ...
    def insert_point_cloud_rays(self, points: numpy.ndarray[numpy.float64[3, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float64[3, 1]], min_range: float, max_range: float, parallel: bool, lazy_eval: bool) -> None:
        ...
    def insert_ray(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float, min_range: float, max_range: float, lazy_eval: bool) -> bool:
        ...
    def is_node_collapsible(self, node: OccupancyOctreeNode) -> bool:
        ...
    @typing.overload
    def iter_bottom_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.BottomLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_bottom_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.BottomLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.EastLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.EastLeafNeighborIterator]:
        ...
    def iter_leaf(self, max_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.LeafIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_min_z: float, aabb_max_x: float, aabb_max_y: float, aabb_max_z: float, max_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.LeafInAabbIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_key: OctreeKey, aabb_max_key: OctreeKey, max_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.LeafInAabbIterator]:
        ...
    def iter_leaf_of_node(self, node_key: OctreeKey, node_depth: int, max_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.LeafOfNodeIterator]:
        ...
    def iter_node(self, max_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.TreeIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_min_z: float, aabb_max_x: float, aabb_max_y: float, aabb_max_z: float, max_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.TreeInAabbIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_key: OctreeKey, aabb_max_key: OctreeKey, max_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.TreeInAabbIterator]:
        ...
    def iter_node_on_ray(self, px: float, py: float, pz: float, vx: float, vy: float, vz: float, max_range: float = -1, node_padding: float = 0, bidirectional: bool = False, leaf_only: bool = True, min_node_depth: int = 0, max_node_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.NodeOnRayIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_top_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.TopLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_top_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.TopLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeD.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def key_to_coord(self, key: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: int, depth: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: OctreeKey) -> tuple[float, float, float]:
        ...
    @typing.overload
    def key_to_coord(self, key: OctreeKey, depth: int) -> tuple[float, float, float]:
        ...
    def prune(self) -> None:
        ...
    def prune_node(self, node: OccupancyOctreeNode) -> bool:
        ...
    def sample_positions(self, num_positions: int) -> list[numpy.ndarray[numpy.float64[3, 1]]]:
        ...
    @typing.overload
    def search(self, x: float, y: float, z: float, max_depth: int = 0) -> OccupancyOctreeNode:
        ...
    @typing.overload
    def search(self, key: OctreeKey, max_depth: int = 0) -> OccupancyOctreeNode:
        ...
    def to_max_likelihood(self) -> None:
        ...
    def update_inner_occupancy(self) -> None:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, z: float, occupied: bool, lazy_eval: bool) -> OccupancyOctreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: OctreeKey, occupied: bool, lazy_eval: bool) -> OccupancyOctreeNode:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, z: float, log_odds_delta: float, lazy_eval: bool) -> OccupancyOctreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: OctreeKey, log_odds_delta: float, lazy_eval: bool) -> OccupancyOctreeNode:
        ...
    def visualize(self, leaf_only: bool = False, scaling: float = 1.0, area_min: numpy.ndarray[numpy.float64[3, 1]] = ..., area_max: numpy.ndarray[numpy.float64[3, 1]] = ..., border_color: numpy.ndarray[numpy.float64[3, 1]] = ..., occupied_color: numpy.ndarray[numpy.float64[3, 1]] = ..., occupied_only: bool = False, draw_node_boxes: bool = True, draw_node_borders: bool = True, window_width: int = 1920, window_height: int = 1080, window_left: int = 50, window_top: int = 50) -> None:
        ...
    @property
    def memory_usage(self) -> int:
        ...
    @property
    def memory_usage_per_node(self) -> int:
        ...
    @property
    def metric_aabb(self) -> Aabb3Dd:
        ...
    @property
    def metric_max(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def metric_min(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def metric_min_max(self) -> tuple[numpy.ndarray[numpy.float64[3, 1]], numpy.ndarray[numpy.float64[3, 1]]]:
        ...
    @property
    def metric_size(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def number_of_leaf_nodes(self) -> int:
        ...
    @property
    def number_of_nodes(self) -> int:
        ...
    @property
    def resolution(self) -> float:
        ...
    @property
    def root(self) -> OccupancyOctreeNode:
        ...
    @property
    def setting(self) -> OccupancyOctreeBaseSetting:
        ...
    @property
    def tree_center(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def tree_center_key(self) -> OctreeKey:
        ...
    @property
    def tree_depth(self) -> int:
        ...
    @property
    def tree_max_half_size(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class OccupancyOctreeDrawerSetting(YamlableBase):
    area_max: numpy.ndarray[numpy.float64[3, 1]]
    area_min: numpy.ndarray[numpy.float64[3, 1]]
    border_color: numpy.ndarray[numpy.float64[3, 1]]
    draw_node_borders: bool
    draw_node_boxes: bool
    occupied_color: numpy.ndarray[numpy.float64[3, 1]]
    occupied_only: bool
    def __init__(self) -> None:
        ...
class OccupancyOctreeF(AbstractOccupancyOctreeF):
    class BatchRayCaster:
        def step(self, max_depth: numpy.ndarray[bool[m, 1]] = 0) -> OccupancyOctreeF.BatchRayCaster:
            ...
        @property
        def ever_hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def frontier_keys(self) -> list[OctreeKey]:
            ...
        @property
        def frontier_nodes(self) -> list[OccupancyOctreeNode]:
            ...
        @property
        def frontier_ray_indices(self) -> list[list[int]]:
            ...
        @property
        def hit_distances(self) -> numpy.ndarray[numpy.float32[m, 1]]:
            ...
        @property
        def hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def hit_nodes(self) -> list[OccupancyOctreeNode]:
            ...
        @property
        def hit_positions(self) -> list[numpy.ndarray[numpy.float32[3, 1]]]:
            ...
        @property
        def num_rays(self) -> int:
            ...
        @property
        def ray_directions(self) -> numpy.ndarray[numpy.float32[3, n]]:
            ...
        @property
        def ray_origins(self) -> numpy.ndarray[numpy.float32[3, n]]:
            ...
    class BottomLeafNeighborIterator(OccupancyOctreeF.IteratorBase):
        pass
    class Drawer:
        @staticmethod
        def Setting() -> OccupancyOctreeDrawerSetting:
            ...
        def __init__(self, setting: OccupancyOctreeDrawerSetting, octree: OccupancyOctreeF = None) -> None:
            ...
        @typing.overload
        def draw_leaves(self) -> list[...]:
            ...
        @typing.overload
        def draw_leaves(self, filename: str) -> None:
            ...
        @typing.overload
        def draw_tree(self) -> list[...]:
            ...
        @typing.overload
        def draw_tree(self, filename: str) -> None:
            ...
        def set_draw_leaf_callback(self, callback: typing.Callable[[OccupancyOctreeF.Drawer, list[...], OccupancyOctreeF.LeafInAabbIterator], None]) -> None:
            ...
        def set_draw_tree_callback(self, callback: typing.Callable[[OccupancyOctreeF.Drawer, list[...], OccupancyOctreeF.TreeInAabbIterator], None]) -> None:
            ...
        @property
        def setting(self) -> OccupancyOctreeDrawerSetting:
            ...
    class EastLeafNeighborIterator(OccupancyOctreeF.IteratorBase):
        pass
    class IteratorBase(AbstractOctreeF.OctreeNodeIterator):
        __hash__: typing.ClassVar[None] = None
        def __eq__(self, arg0: OccupancyOctreeF.IteratorBase) -> bool:
            ...
        def __ne__(self, arg0: OccupancyOctreeF.IteratorBase) -> bool:
            ...
        @property
        def index_key(self) -> OctreeKey:
            ...
        @property
        def key(self) -> OctreeKey:
            ...
        @property
        def node(self) -> OccupancyOctreeNode:
            ...
        @property
        def node_aabb(self) -> Aabb3Df:
            ...
    class LeafInAabbIterator(OccupancyOctreeF.IteratorBase):
        pass
    class LeafIterator(OccupancyOctreeF.IteratorBase):
        pass
    class LeafOfNodeIterator(OccupancyOctreeF.IteratorBase):
        pass
    class NodeOnRayIterator(OccupancyOctreeF.IteratorBase):
        @property
        def distance(self) -> float:
            ...
    class NorthLeafNeighborIterator(OccupancyOctreeF.IteratorBase):
        pass
    class SouthLeafNeighborIterator(OccupancyOctreeF.IteratorBase):
        pass
    class TopLeafNeighborIterator(OccupancyOctreeF.IteratorBase):
        pass
    class TreeInAabbIterator(OccupancyOctreeF.IteratorBase):
        pass
    class TreeIterator(OccupancyOctreeF.IteratorBase):
        pass
    class WestLeafNeighborIterator(OccupancyOctreeF.IteratorBase):
        pass
    @staticmethod
    def Setting() -> OccupancyOctreeBaseSetting:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, setting: OccupancyOctreeBaseSetting) -> None:
        ...
    @typing.overload
    def __init__(self, filename: str) -> None:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: int, depth: int) -> int:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: OctreeKey, depth: int) -> OctreeKey:
        ...
    def cast_ray(self, px: float, py: float, pz: float, vx: float, vy: float, vz: float, ignore_unknown: bool, max_range: float) -> dict:
        ...
    @typing.overload
    def cast_rays(self, position: numpy.ndarray[numpy.float32[3, 1]], rotation: numpy.ndarray[numpy.float32[3, 3], numpy.ndarray.flags.f_contiguous], azimuth_angles: numpy.ndarray[numpy.float32[m, 1]], elevation_angles: numpy.ndarray[numpy.float32[m, 1]], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    @typing.overload
    def cast_rays(self, positions: numpy.ndarray[numpy.float32[3, n], numpy.ndarray.flags.f_contiguous], directions: numpy.ndarray[numpy.float32[3, n], numpy.ndarray.flags.f_contiguous], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    def clear(self) -> None:
        ...
    def compute_bottom_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_common_ancestor_key(self, arg0: OctreeKey, arg1: OctreeKey) -> tuple[OctreeKey, int]:
        ...
    def compute_east_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_north_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_ray_coords(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float) -> list[numpy.ndarray[numpy.float32[3, 1]]] | None:
        ...
    def compute_ray_keys(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float) -> list[OctreeKey] | None:
        ...
    def compute_south_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_top_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_west_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float) -> int:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float, depth: int) -> int:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, z: float) -> OctreeKey:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, z: float, depth: int) -> OctreeKey:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float, depth: int) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, z: float) -> OctreeKey | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, z: float, depth: int) -> OctreeKey | None:
        ...
    def create_node_child(self, node: OccupancyOctreeNode, child_idx: int) -> OccupancyOctreeNode:
        ...
    @typing.overload
    def delete_node(self, x: float, y: float, z: float, depth: int) -> int:
        ...
    @typing.overload
    def delete_node(self, key: OctreeKey, depth: int) -> None:
        ...
    def delete_node_child(self, node: OccupancyOctreeNode, child_idx: int, key: OctreeKey) -> int:
        ...
    def expand(self) -> None:
        ...
    def expand_node(self, node: OccupancyOctreeNode) -> None:
        ...
    def get_batch_ray_caster(self, origins: numpy.ndarray[numpy.float32[3, n]], directions: numpy.ndarray[numpy.float32[3, n]], max_ranges: numpy.ndarray[numpy.float32[m, 1]] = ..., node_paddings: numpy.ndarray[numpy.float32[m, 1]] = ..., bidirectional_flags: numpy.ndarray[bool[m, 1]] = ..., leaf_only_flags: numpy.ndarray[bool[m, 1]] = ..., min_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ..., max_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ...) -> ...:
        ...
    def get_node_child(self, node: OccupancyOctreeNode, child_idx: int) -> OccupancyOctreeNode:
        ...
    def get_node_size(self, depth: int) -> float:
        ...
    @typing.overload
    def insert_node(self, x: float, y: float, z: float, depth: int) -> OccupancyOctreeNode:
        ...
    @typing.overload
    def insert_node(self, key: OctreeKey, depth: int) -> OccupancyOctreeNode:
        ...
    def insert_point_cloud(self, points: numpy.ndarray[numpy.float32[3, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float32[3, 1]], min_range: float, max_range: float, with_count: bool, parallel: bool, lazy_eval: bool, discrete: bool) -> None:
        ...
    def insert_point_cloud_rays(self, points: numpy.ndarray[numpy.float32[3, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float32[3, 1]], min_range: float, max_range: float, parallel: bool, lazy_eval: bool) -> None:
        ...
    def insert_ray(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float, min_range: float, max_range: float, lazy_eval: bool) -> bool:
        ...
    def is_node_collapsible(self, node: OccupancyOctreeNode) -> bool:
        ...
    @typing.overload
    def iter_bottom_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.BottomLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_bottom_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.BottomLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.EastLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.EastLeafNeighborIterator]:
        ...
    def iter_leaf(self, max_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.LeafIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_min_z: float, aabb_max_x: float, aabb_max_y: float, aabb_max_z: float, max_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.LeafInAabbIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_key: OctreeKey, aabb_max_key: OctreeKey, max_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.LeafInAabbIterator]:
        ...
    def iter_leaf_of_node(self, node_key: OctreeKey, node_depth: int, max_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.LeafOfNodeIterator]:
        ...
    def iter_node(self, max_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.TreeIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_min_z: float, aabb_max_x: float, aabb_max_y: float, aabb_max_z: float, max_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.TreeInAabbIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_key: OctreeKey, aabb_max_key: OctreeKey, max_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.TreeInAabbIterator]:
        ...
    def iter_node_on_ray(self, px: float, py: float, pz: float, vx: float, vy: float, vz: float, max_range: float = -1, node_padding: float = 0, bidirectional: bool = False, leaf_only: bool = True, min_node_depth: int = 0, max_node_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.NodeOnRayIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_top_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.TopLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_top_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.TopLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyOctreeF.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def key_to_coord(self, key: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: int, depth: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: OctreeKey) -> tuple[float, float, float]:
        ...
    @typing.overload
    def key_to_coord(self, key: OctreeKey, depth: int) -> tuple[float, float, float]:
        ...
    def prune(self) -> None:
        ...
    def prune_node(self, node: OccupancyOctreeNode) -> bool:
        ...
    def sample_positions(self, num_positions: int) -> list[numpy.ndarray[numpy.float32[3, 1]]]:
        ...
    @typing.overload
    def search(self, x: float, y: float, z: float, max_depth: int = 0) -> OccupancyOctreeNode:
        ...
    @typing.overload
    def search(self, key: OctreeKey, max_depth: int = 0) -> OccupancyOctreeNode:
        ...
    def to_max_likelihood(self) -> None:
        ...
    def update_inner_occupancy(self) -> None:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, z: float, occupied: bool, lazy_eval: bool) -> OccupancyOctreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: OctreeKey, occupied: bool, lazy_eval: bool) -> OccupancyOctreeNode:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, z: float, log_odds_delta: float, lazy_eval: bool) -> OccupancyOctreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: OctreeKey, log_odds_delta: float, lazy_eval: bool) -> OccupancyOctreeNode:
        ...
    def visualize(self, leaf_only: bool = False, scaling: float = 1.0, area_min: numpy.ndarray[numpy.float64[3, 1]] = ..., area_max: numpy.ndarray[numpy.float64[3, 1]] = ..., border_color: numpy.ndarray[numpy.float64[3, 1]] = ..., occupied_color: numpy.ndarray[numpy.float64[3, 1]] = ..., occupied_only: bool = False, draw_node_boxes: bool = True, draw_node_borders: bool = True, window_width: int = 1920, window_height: int = 1080, window_left: int = 50, window_top: int = 50) -> None:
        ...
    @property
    def memory_usage(self) -> int:
        ...
    @property
    def memory_usage_per_node(self) -> int:
        ...
    @property
    def metric_aabb(self) -> Aabb3Df:
        ...
    @property
    def metric_max(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def metric_min(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def metric_min_max(self) -> tuple[numpy.ndarray[numpy.float32[3, 1]], numpy.ndarray[numpy.float32[3, 1]]]:
        ...
    @property
    def metric_size(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def number_of_leaf_nodes(self) -> int:
        ...
    @property
    def number_of_nodes(self) -> int:
        ...
    @property
    def resolution(self) -> float:
        ...
    @property
    def root(self) -> OccupancyOctreeNode:
        ...
    @property
    def setting(self) -> OccupancyOctreeBaseSetting:
        ...
    @property
    def tree_center(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def tree_center_key(self) -> OctreeKey:
        ...
    @property
    def tree_depth(self) -> int:
        ...
    @property
    def tree_max_half_size(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
class OccupancyOctreeNode(AbstractOctreeNode):
    def add_log_odds(self, log_odds: float) -> None:
        ...
    def allow_update_log_odds(self, delta: float) -> bool:
        ...
    def get_child(self, child_idx: int) -> OccupancyOctreeNode:
        ...
    @property
    def log_odds(self) -> float:
        ...
    @property
    def max_child_log_odds(self) -> float:
        ...
    @property
    def mean_child_log_odds(self) -> float:
        ...
    @property
    def occupancy(self) -> float:
        ...
class OccupancyQuadtreeBaseSetting(OccupancyNdTreeSetting):
    aabb: Aabb2Dd
    use_aabb_limit: bool
    use_change_detection: bool
    def __init__(self) -> None:
        ...
class OccupancyQuadtreeD(AbstractOccupancyQuadtreeD):
    class BatchRayCaster:
        def step(self, mask: numpy.ndarray[bool[m, 1]] = ...) -> OccupancyQuadtreeD.BatchRayCaster:
            ...
        @property
        def ever_hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def frontier_keys(self) -> list[QuadtreeKey]:
            ...
        @property
        def frontier_nodes(self) -> list[OccupancyQuadtreeNode]:
            ...
        @property
        def frontier_ray_indices(self) -> list[list[int]]:
            ...
        @property
        def hit_distances(self) -> numpy.ndarray[numpy.float64[m, 1]]:
            ...
        @property
        def hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def hit_nodes(self) -> list[OccupancyQuadtreeNode]:
            ...
        @property
        def hit_positions(self) -> list[numpy.ndarray[numpy.float64[2, 1]]]:
            ...
        @property
        def num_rays(self) -> int:
            ...
        @property
        def ray_directions(self) -> numpy.ndarray[numpy.float64[2, n]]:
            ...
        @property
        def ray_origins(self) -> numpy.ndarray[numpy.float64[2, n]]:
            ...
    class Drawer:
        @staticmethod
        def Setting() -> OccupancyQuadtreeDrawerSettingD:
            ...
        def __init__(self, setting: OccupancyQuadtreeDrawerSettingD, quadtree: OccupancyQuadtreeD = None) -> None:
            ...
        @typing.overload
        def draw_leaves(self) -> Mat:
            ...
        @typing.overload
        def draw_leaves(self, filename: str) -> None:
            ...
        @typing.overload
        def draw_tree(self) -> Mat:
            ...
        @typing.overload
        def draw_tree(self, filename: str) -> None:
            ...
        def set_draw_leaf_callback(self, callback: typing.Callable[[OccupancyQuadtreeD.Drawer, Mat, OccupancyQuadtreeD.LeafIterator], None]) -> None:
            ...
        def set_draw_tree_callback(self, callback: typing.Callable[[OccupancyQuadtreeD.Drawer, Mat, OccupancyQuadtreeD.TreeIterator], None]) -> None:
            ...
        @property
        def grid_map_info(self) -> ...:
            ...
        @property
        def setting(self) -> OccupancyQuadtreeDrawerSettingD:
            ...
    class EastLeafNeighborIterator(OccupancyQuadtreeD.IteratorBase):
        pass
    class IteratorBase(AbstractQuadtreeD.QuadtreeNodeIterator):
        __hash__: typing.ClassVar[None] = None
        def __eq__(self, arg0: OccupancyQuadtreeD.IteratorBase) -> bool:
            ...
        def __ne__(self, arg0: OccupancyQuadtreeD.IteratorBase) -> bool:
            ...
        @property
        def index_key(self) -> QuadtreeKey:
            ...
        @property
        def key(self) -> QuadtreeKey:
            ...
        @property
        def node(self) -> OccupancyQuadtreeNode:
            ...
        @property
        def node_aabb(self) -> Aabb2Dd:
            ...
    class LeafInAabbIterator(OccupancyQuadtreeD.IteratorBase):
        pass
    class LeafIterator(OccupancyQuadtreeD.IteratorBase):
        pass
    class LeafOfNodeIterator(OccupancyQuadtreeD.IteratorBase):
        pass
    class NodeOnRayIterator(OccupancyQuadtreeD.IteratorBase):
        @property
        def distance(self) -> float:
            ...
    class NorthLeafNeighborIterator(OccupancyQuadtreeD.IteratorBase):
        pass
    class SouthLeafNeighborIterator(OccupancyQuadtreeD.IteratorBase):
        pass
    class TreeInAabbIterator(OccupancyQuadtreeD.IteratorBase):
        pass
    class TreeIterator(OccupancyQuadtreeD.IteratorBase):
        pass
    class WestLeafNeighborIterator(OccupancyQuadtreeD.IteratorBase):
        pass
    @staticmethod
    def Setting() -> OccupancyQuadtreeBaseSetting:
        ...
    @staticmethod
    @typing.overload
    def __init__(*args, **kwargs) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, setting: OccupancyQuadtreeBaseSetting) -> None:
        ...
    @typing.overload
    def __init__(self, filename: str) -> None:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: int, depth: int) -> int:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: QuadtreeKey, depth: int) -> QuadtreeKey:
        ...
    def cast_ray(self, px: float, py: float, vx: float, vy: float, ignore_unknown: bool, max_range: float) -> dict:
        ...
    @typing.overload
    def cast_rays(self, position: numpy.ndarray[numpy.float64[2, 1]], rotation: numpy.ndarray[numpy.float64[2, 2], numpy.ndarray.flags.f_contiguous], angles: numpy.ndarray[numpy.float64[m, 1]], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    @typing.overload
    def cast_rays(self, positions: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous], directions: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    def clear(self) -> None:
        ...
    def compute_common_ancestor_key(self, arg0: QuadtreeKey, arg1: QuadtreeKey) -> tuple[QuadtreeKey, int]:
        ...
    def compute_east_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_north_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_ray_coords(self, sx: float, sy: float, ex: float, ey: float) -> list[numpy.ndarray[numpy.float64[2, 1]]] | None:
        ...
    def compute_ray_keys(self, sx: float, sy: float, ex: float, ey: float) -> list[QuadtreeKey] | None:
        ...
    def compute_south_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_west_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float) -> int:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float, depth: int) -> int:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float) -> QuadtreeKey:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, depth: int) -> QuadtreeKey:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float, depth: int) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float) -> QuadtreeKey | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, depth: int) -> QuadtreeKey | None:
        ...
    def create_node_child(self, node: OccupancyQuadtreeNode, child_idx: int) -> OccupancyQuadtreeNode:
        ...
    @typing.overload
    def delete_node(self, x: float, y: float, depth: int) -> int:
        ...
    @typing.overload
    def delete_node(self, key: QuadtreeKey, depth: int) -> None:
        ...
    def delete_node_child(self, node: OccupancyQuadtreeNode, child_idx: int, key: QuadtreeKey) -> int:
        ...
    def expand(self) -> None:
        ...
    def expand_node(self, node: OccupancyQuadtreeNode) -> None:
        ...
    def get_batch_ray_caster(self, origins: numpy.ndarray[numpy.float64[2, n]], directions: numpy.ndarray[numpy.float64[2, n]], max_ranges: numpy.ndarray[numpy.float64[m, 1]] = ..., node_paddings: numpy.ndarray[numpy.float64[m, 1]] = ..., bidirectional_flags: numpy.ndarray[bool[m, 1]] = ..., leaf_only_flags: numpy.ndarray[bool[m, 1]] = ..., min_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ..., max_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ...) -> ...:
        ...
    def get_node_child(self, node: OccupancyQuadtreeNode, child_idx: int) -> OccupancyQuadtreeNode:
        ...
    def get_node_size(self, depth: int) -> float:
        ...
    @typing.overload
    def insert_node(self, x: float, y: float, depth: int) -> OccupancyQuadtreeNode:
        ...
    @typing.overload
    def insert_node(self, key: QuadtreeKey, depth: int) -> OccupancyQuadtreeNode:
        ...
    def insert_point_cloud(self, points: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float64[2, 1]], min_range: float, max_range: float, with_count: bool, parallel: bool, lazy_eval: bool, discrete: bool) -> None:
        ...
    def insert_point_cloud_rays(self, points: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float64[2, 1]], min_range: float, max_range: float, parallel: bool, lazy_eval: bool) -> None:
        ...
    def insert_ray(self, sx: float, sy: float, ex: float, ey: float, min_range: float, max_range: float, lazy_eval: bool) -> bool:
        ...
    def is_node_collapsible(self, node: OccupancyQuadtreeNode) -> bool:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.EastLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.EastLeafNeighborIterator]:
        ...
    def iter_leaf(self, max_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.LeafIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_max_x: float, aabb_max_y: float, max_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.LeafInAabbIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_key: QuadtreeKey, aabb_max_key: QuadtreeKey, max_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.LeafInAabbIterator]:
        ...
    def iter_leaf_of_node(self, node_key: QuadtreeKey, node_depth: int, max_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.LeafOfNodeIterator]:
        ...
    def iter_node(self, max_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.TreeIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_max_x: float, aabb_max_y: float, max_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.TreeInAabbIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_key: QuadtreeKey, aabb_max_key: QuadtreeKey, max_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.TreeInAabbIterator]:
        ...
    def iter_node_on_ray(self, px: float, py: float, vx: float, vy: float, max_range: float = -1, node_padding: float = 0, bidirectional: bool = False, leaf_only: bool = False, min_node_depth: int = 0, max_node_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.NodeOnRayIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeD.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def key_to_coord(self, key: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: int, depth: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: QuadtreeKey) -> tuple[float, float]:
        ...
    @typing.overload
    def key_to_coord(self, key: QuadtreeKey, depth: int) -> tuple[float, float]:
        ...
    def prune(self) -> None:
        ...
    def prune_node(self, node: OccupancyQuadtreeNode) -> bool:
        ...
    def sample_positions(self, num_positions: int) -> list[numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    @typing.overload
    def search(self, x: float, y: float, max_depth: int = 0) -> OccupancyQuadtreeNode:
        ...
    @typing.overload
    def search(self, key: QuadtreeKey, max_depth: int = 0) -> OccupancyQuadtreeNode:
        ...
    def to_max_likelihood(self) -> None:
        ...
    def update_inner_occupancy(self) -> None:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, occupied: bool, lazy_eval: bool) -> OccupancyQuadtreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: QuadtreeKey, occupied: bool, lazy_eval: bool) -> OccupancyQuadtreeNode:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, log_odds_delta: float, lazy_eval: bool) -> OccupancyQuadtreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: QuadtreeKey, log_odds_delta: float, lazy_eval: bool) -> OccupancyQuadtreeNode:
        ...
    def visualize(self, leaf_only: bool = False, area_min: numpy.ndarray[numpy.float32[2, 1]] | None = None, area_max: numpy.ndarray[numpy.float32[2, 1]] | None = None, resolution: float = 0.1, padding: int = 1, bg_color: numpy.ndarray[numpy.int32[4, 1]] = ..., fg_color: numpy.ndarray[numpy.int32[4, 1]] = ..., occupied_color: numpy.ndarray[numpy.int32[4, 1]] = ..., free_color: numpy.ndarray[numpy.int32[4, 1]] = ..., border_color: numpy.ndarray[numpy.int32[4, 1]] = ..., border_thickness: int = 1) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def memory_usage(self) -> int:
        ...
    @property
    def memory_usage_per_node(self) -> int:
        ...
    @property
    def metric_aabb(self) -> Aabb2Dd:
        ...
    @property
    def metric_max(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def metric_min(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def metric_min_max(self) -> tuple[numpy.ndarray[numpy.float64[2, 1]], numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    @property
    def metric_size(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def number_of_leaf_nodes(self) -> int:
        ...
    @property
    def number_of_nodes(self) -> int:
        ...
    @property
    def resolution(self) -> float:
        ...
    @property
    def root(self) -> OccupancyQuadtreeNode:
        ...
    @property
    def setting(self) -> OccupancyQuadtreeBaseSetting:
        ...
    @property
    def tree_center(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def tree_center_key(self) -> QuadtreeKey:
        ...
    @property
    def tree_depth(self) -> int:
        ...
    @property
    def tree_max_half_size(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class OccupancyQuadtreeDrawerSettingD(YamlableBase):
    area_max: numpy.ndarray[numpy.float32[2, 1]]
    area_min: numpy.ndarray[numpy.float32[2, 1]]
    bg_color: Scalar
    border_color: Scalar
    border_thickness: int
    fg_color: Scalar
    free_color: Scalar
    occupied_color: Scalar
    padding: int
    resolution: float
    scaling: float
    def __init__(self) -> None:
        ...
class OccupancyQuadtreeDrawerSettingF(YamlableBase):
    area_max: numpy.ndarray[numpy.float32[2, 1]]
    area_min: numpy.ndarray[numpy.float32[2, 1]]
    bg_color: Scalar
    border_color: Scalar
    border_thickness: int
    fg_color: Scalar
    free_color: Scalar
    occupied_color: Scalar
    padding: int
    resolution: float
    scaling: float
    def __init__(self) -> None:
        ...
class OccupancyQuadtreeF(AbstractOccupancyQuadtreeF):
    class BatchRayCaster:
        def step(self, mask: numpy.ndarray[bool[m, 1]] = ...) -> OccupancyQuadtreeF.BatchRayCaster:
            ...
        @property
        def ever_hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def frontier_keys(self) -> list[QuadtreeKey]:
            ...
        @property
        def frontier_nodes(self) -> list[OccupancyQuadtreeNode]:
            ...
        @property
        def frontier_ray_indices(self) -> list[list[int]]:
            ...
        @property
        def hit_distances(self) -> numpy.ndarray[numpy.float32[m, 1]]:
            ...
        @property
        def hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def hit_nodes(self) -> list[OccupancyQuadtreeNode]:
            ...
        @property
        def hit_positions(self) -> list[numpy.ndarray[numpy.float32[2, 1]]]:
            ...
        @property
        def num_rays(self) -> int:
            ...
        @property
        def ray_directions(self) -> numpy.ndarray[numpy.float32[2, n]]:
            ...
        @property
        def ray_origins(self) -> numpy.ndarray[numpy.float32[2, n]]:
            ...
    class Drawer:
        @staticmethod
        def Setting() -> OccupancyQuadtreeDrawerSettingF:
            ...
        def __init__(self, setting: OccupancyQuadtreeDrawerSettingF, quadtree: OccupancyQuadtreeF = None) -> None:
            ...
        @typing.overload
        def draw_leaves(self) -> Mat:
            ...
        @typing.overload
        def draw_leaves(self, filename: str) -> None:
            ...
        @typing.overload
        def draw_tree(self) -> Mat:
            ...
        @typing.overload
        def draw_tree(self, filename: str) -> None:
            ...
        def set_draw_leaf_callback(self, callback: typing.Callable[[OccupancyQuadtreeF.Drawer, Mat, OccupancyQuadtreeF.LeafIterator], None]) -> None:
            ...
        def set_draw_tree_callback(self, callback: typing.Callable[[OccupancyQuadtreeF.Drawer, Mat, OccupancyQuadtreeF.TreeIterator], None]) -> None:
            ...
        @property
        def grid_map_info(self) -> ...:
            ...
        @property
        def setting(self) -> OccupancyQuadtreeDrawerSettingF:
            ...
    class EastLeafNeighborIterator(OccupancyQuadtreeF.IteratorBase):
        pass
    class IteratorBase(AbstractQuadtreeF.QuadtreeNodeIterator):
        __hash__: typing.ClassVar[None] = None
        def __eq__(self, arg0: OccupancyQuadtreeF.IteratorBase) -> bool:
            ...
        def __ne__(self, arg0: OccupancyQuadtreeF.IteratorBase) -> bool:
            ...
        @property
        def index_key(self) -> QuadtreeKey:
            ...
        @property
        def key(self) -> QuadtreeKey:
            ...
        @property
        def node(self) -> OccupancyQuadtreeNode:
            ...
        @property
        def node_aabb(self) -> Aabb2Df:
            ...
    class LeafInAabbIterator(OccupancyQuadtreeF.IteratorBase):
        pass
    class LeafIterator(OccupancyQuadtreeF.IteratorBase):
        pass
    class LeafOfNodeIterator(OccupancyQuadtreeF.IteratorBase):
        pass
    class NodeOnRayIterator(OccupancyQuadtreeF.IteratorBase):
        @property
        def distance(self) -> float:
            ...
    class NorthLeafNeighborIterator(OccupancyQuadtreeF.IteratorBase):
        pass
    class SouthLeafNeighborIterator(OccupancyQuadtreeF.IteratorBase):
        pass
    class TreeInAabbIterator(OccupancyQuadtreeF.IteratorBase):
        pass
    class TreeIterator(OccupancyQuadtreeF.IteratorBase):
        pass
    class WestLeafNeighborIterator(OccupancyQuadtreeF.IteratorBase):
        pass
    @staticmethod
    def Setting() -> OccupancyQuadtreeBaseSetting:
        ...
    @staticmethod
    @typing.overload
    def __init__(*args, **kwargs) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, setting: OccupancyQuadtreeBaseSetting) -> None:
        ...
    @typing.overload
    def __init__(self, filename: str) -> None:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: int, depth: int) -> int:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: QuadtreeKey, depth: int) -> QuadtreeKey:
        ...
    def cast_ray(self, px: float, py: float, vx: float, vy: float, ignore_unknown: bool, max_range: float) -> dict:
        ...
    @typing.overload
    def cast_rays(self, position: numpy.ndarray[numpy.float32[2, 1]], rotation: numpy.ndarray[numpy.float32[2, 2], numpy.ndarray.flags.f_contiguous], angles: numpy.ndarray[numpy.float32[m, 1]], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    @typing.overload
    def cast_rays(self, positions: numpy.ndarray[numpy.float32[2, n], numpy.ndarray.flags.f_contiguous], directions: numpy.ndarray[numpy.float32[2, n], numpy.ndarray.flags.f_contiguous], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    def clear(self) -> None:
        ...
    def compute_common_ancestor_key(self, arg0: QuadtreeKey, arg1: QuadtreeKey) -> tuple[QuadtreeKey, int]:
        ...
    def compute_east_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_north_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_ray_coords(self, sx: float, sy: float, ex: float, ey: float) -> list[numpy.ndarray[numpy.float32[2, 1]]] | None:
        ...
    def compute_ray_keys(self, sx: float, sy: float, ex: float, ey: float) -> list[QuadtreeKey] | None:
        ...
    def compute_south_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_west_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float) -> int:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float, depth: int) -> int:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float) -> QuadtreeKey:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, depth: int) -> QuadtreeKey:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float, depth: int) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float) -> QuadtreeKey | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, depth: int) -> QuadtreeKey | None:
        ...
    def create_node_child(self, node: OccupancyQuadtreeNode, child_idx: int) -> OccupancyQuadtreeNode:
        ...
    @typing.overload
    def delete_node(self, x: float, y: float, depth: int) -> int:
        ...
    @typing.overload
    def delete_node(self, key: QuadtreeKey, depth: int) -> None:
        ...
    def delete_node_child(self, node: OccupancyQuadtreeNode, child_idx: int, key: QuadtreeKey) -> int:
        ...
    def expand(self) -> None:
        ...
    def expand_node(self, node: OccupancyQuadtreeNode) -> None:
        ...
    def get_batch_ray_caster(self, origins: numpy.ndarray[numpy.float32[2, n]], directions: numpy.ndarray[numpy.float32[2, n]], max_ranges: numpy.ndarray[numpy.float32[m, 1]] = ..., node_paddings: numpy.ndarray[numpy.float32[m, 1]] = ..., bidirectional_flags: numpy.ndarray[bool[m, 1]] = ..., leaf_only_flags: numpy.ndarray[bool[m, 1]] = ..., min_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ..., max_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ...) -> ...:
        ...
    def get_node_child(self, node: OccupancyQuadtreeNode, child_idx: int) -> OccupancyQuadtreeNode:
        ...
    def get_node_size(self, depth: int) -> float:
        ...
    @typing.overload
    def insert_node(self, x: float, y: float, depth: int) -> OccupancyQuadtreeNode:
        ...
    @typing.overload
    def insert_node(self, key: QuadtreeKey, depth: int) -> OccupancyQuadtreeNode:
        ...
    def insert_point_cloud(self, points: numpy.ndarray[numpy.float32[2, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float32[2, 1]], min_range: float, max_range: float, with_count: bool, parallel: bool, lazy_eval: bool, discrete: bool) -> None:
        ...
    def insert_point_cloud_rays(self, points: numpy.ndarray[numpy.float32[2, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float32[2, 1]], min_range: float, max_range: float, parallel: bool, lazy_eval: bool) -> None:
        ...
    def insert_ray(self, sx: float, sy: float, ex: float, ey: float, min_range: float, max_range: float, lazy_eval: bool) -> bool:
        ...
    def is_node_collapsible(self, node: OccupancyQuadtreeNode) -> bool:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.EastLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.EastLeafNeighborIterator]:
        ...
    def iter_leaf(self, max_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.LeafIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_max_x: float, aabb_max_y: float, max_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.LeafInAabbIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_key: QuadtreeKey, aabb_max_key: QuadtreeKey, max_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.LeafInAabbIterator]:
        ...
    def iter_leaf_of_node(self, node_key: QuadtreeKey, node_depth: int, max_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.LeafOfNodeIterator]:
        ...
    def iter_node(self, max_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.TreeIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_max_x: float, aabb_max_y: float, max_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.TreeInAabbIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_key: QuadtreeKey, aabb_max_key: QuadtreeKey, max_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.TreeInAabbIterator]:
        ...
    def iter_node_on_ray(self, px: float, py: float, vx: float, vy: float, max_range: float = -1, node_padding: float = 0, bidirectional: bool = False, leaf_only: bool = False, min_node_depth: int = 0, max_node_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.NodeOnRayIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[OccupancyQuadtreeF.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def key_to_coord(self, key: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: int, depth: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: QuadtreeKey) -> tuple[float, float]:
        ...
    @typing.overload
    def key_to_coord(self, key: QuadtreeKey, depth: int) -> tuple[float, float]:
        ...
    def prune(self) -> None:
        ...
    def prune_node(self, node: OccupancyQuadtreeNode) -> bool:
        ...
    def sample_positions(self, num_positions: int) -> list[numpy.ndarray[numpy.float32[2, 1]]]:
        ...
    @typing.overload
    def search(self, x: float, y: float, max_depth: int = 0) -> OccupancyQuadtreeNode:
        ...
    @typing.overload
    def search(self, key: QuadtreeKey, max_depth: int = 0) -> OccupancyQuadtreeNode:
        ...
    def to_max_likelihood(self) -> None:
        ...
    def update_inner_occupancy(self) -> None:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, occupied: bool, lazy_eval: bool) -> OccupancyQuadtreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: QuadtreeKey, occupied: bool, lazy_eval: bool) -> OccupancyQuadtreeNode:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, log_odds_delta: float, lazy_eval: bool) -> OccupancyQuadtreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: QuadtreeKey, log_odds_delta: float, lazy_eval: bool) -> OccupancyQuadtreeNode:
        ...
    def visualize(self, leaf_only: bool = False, area_min: numpy.ndarray[numpy.float32[2, 1]] | None = None, area_max: numpy.ndarray[numpy.float32[2, 1]] | None = None, resolution: float = 0.1, padding: int = 1, bg_color: numpy.ndarray[numpy.int32[4, 1]] = ..., fg_color: numpy.ndarray[numpy.int32[4, 1]] = ..., occupied_color: numpy.ndarray[numpy.int32[4, 1]] = ..., free_color: numpy.ndarray[numpy.int32[4, 1]] = ..., border_color: numpy.ndarray[numpy.int32[4, 1]] = ..., border_thickness: int = 1) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def memory_usage(self) -> int:
        ...
    @property
    def memory_usage_per_node(self) -> int:
        ...
    @property
    def metric_aabb(self) -> Aabb2Df:
        ...
    @property
    def metric_max(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def metric_min(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def metric_min_max(self) -> tuple[numpy.ndarray[numpy.float32[2, 1]], numpy.ndarray[numpy.float32[2, 1]]]:
        ...
    @property
    def metric_size(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def number_of_leaf_nodes(self) -> int:
        ...
    @property
    def number_of_nodes(self) -> int:
        ...
    @property
    def resolution(self) -> float:
        ...
    @property
    def root(self) -> OccupancyQuadtreeNode:
        ...
    @property
    def setting(self) -> OccupancyQuadtreeBaseSetting:
        ...
    @property
    def tree_center(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def tree_center_key(self) -> QuadtreeKey:
        ...
    @property
    def tree_depth(self) -> int:
        ...
    @property
    def tree_max_half_size(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
class OccupancyQuadtreeNode(AbstractQuadtreeNode):
    def add_log_odds(self, log_odds: float) -> None:
        ...
    def allow_update_log_odds(self, delta: float) -> bool:
        ...
    def get_child(self, child_idx: int) -> OccupancyQuadtreeNode:
        ...
    @property
    def log_odds(self) -> float:
        ...
    @property
    def max_child_log_odds(self) -> float:
        ...
    @property
    def mean_child_log_odds(self) -> float:
        ...
    @property
    def occupancy(self) -> float:
        ...
class OctreeKey:
    def __eq__(self, arg0: OctreeKey) -> bool:
        ...
    def __getitem__(self, arg0: int) -> int:
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, a: int, b: int, c: int) -> None:
        ...
    def __ne__(self, arg0: OctreeKey) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def to_list(self) -> list:
        ...
class Primitive2D:
    class Type:
        """
        Members:
        
          kLine2D
        
          kSegment2D
        
          kRay2D
        
          kAxisAlignedRectangle
        
          kRectangle
        
          kEllipse
        """
        __members__: typing.ClassVar[dict[str, Primitive2D.Type]]  # value = {'kLine2D': <Type.kLine2D: 0>, 'kSegment2D': <Type.kSegment2D: 1>, 'kRay2D': <Type.kRay2D: 2>, 'kAxisAlignedRectangle': <Type.kAxisAlignedRectangle: 3>, 'kRectangle': <Type.kRectangle: 4>, 'kEllipse': <Type.kEllipse: 5>}
        kAxisAlignedRectangle: typing.ClassVar[Primitive2D.Type]  # value = <Type.kAxisAlignedRectangle: 3>
        kEllipse: typing.ClassVar[Primitive2D.Type]  # value = <Type.kEllipse: 5>
        kLine2D: typing.ClassVar[Primitive2D.Type]  # value = <Type.kLine2D: 0>
        kRay2D: typing.ClassVar[Primitive2D.Type]  # value = <Type.kRay2D: 2>
        kRectangle: typing.ClassVar[Primitive2D.Type]  # value = <Type.kRectangle: 4>
        kSegment2D: typing.ClassVar[Primitive2D.Type]  # value = <Type.kSegment2D: 1>
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    kAxisAlignedRectangle: typing.ClassVar[Primitive2D.Type]  # value = <Type.kAxisAlignedRectangle: 3>
    kEllipse: typing.ClassVar[Primitive2D.Type]  # value = <Type.kEllipse: 5>
    kLine2D: typing.ClassVar[Primitive2D.Type]  # value = <Type.kLine2D: 0>
    kRay2D: typing.ClassVar[Primitive2D.Type]  # value = <Type.kRay2D: 2>
    kRectangle: typing.ClassVar[Primitive2D.Type]  # value = <Type.kRectangle: 4>
    kSegment2D: typing.ClassVar[Primitive2D.Type]  # value = <Type.kSegment2D: 1>
    id: int
    @typing.overload
    def compute_intersections(self, line: ...) -> list[numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    @typing.overload
    def compute_intersections(self, segment: ...) -> list[numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    @typing.overload
    def compute_intersections(self, ray: ...) -> list[numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    def is_inside(self, point: numpy.ndarray[numpy.float64[2, 1]]) -> bool:
        ...
    def is_on_boundary(self, point: numpy.ndarray[numpy.float64[2, 1]]) -> bool:
        ...
    @property
    def orientation_angle(self) -> float:
        ...
    @property
    def type(self) -> Primitive2D.Type:
        ...
class Primitive3D:
    class Type:
        """
        Members:
        
          kLine3D
        
          kSegment3D
        
          kRay3D
        
          kPlane
        
          kTriangle
        
          kAxisAlignedBox
        
          kBox
        
          kEllipsoid
        """
        __members__: typing.ClassVar[dict[str, Primitive3D.Type]]  # value = {'kLine3D': <Type.kLine3D: 0>, 'kSegment3D': <Type.kSegment3D: 1>, 'kRay3D': <Type.kRay3D: 2>, 'kPlane': <Type.kPlane: 3>, 'kTriangle': <Type.kTriangle: 4>, 'kAxisAlignedBox': <Type.kAxisAlignedBox: 5>, 'kBox': <Type.kBox: 6>, 'kEllipsoid': <Type.kEllipsoid: 7>}
        kAxisAlignedBox: typing.ClassVar[Primitive3D.Type]  # value = <Type.kAxisAlignedBox: 5>
        kBox: typing.ClassVar[Primitive3D.Type]  # value = <Type.kBox: 6>
        kEllipsoid: typing.ClassVar[Primitive3D.Type]  # value = <Type.kEllipsoid: 7>
        kLine3D: typing.ClassVar[Primitive3D.Type]  # value = <Type.kLine3D: 0>
        kPlane: typing.ClassVar[Primitive3D.Type]  # value = <Type.kPlane: 3>
        kRay3D: typing.ClassVar[Primitive3D.Type]  # value = <Type.kRay3D: 2>
        kSegment3D: typing.ClassVar[Primitive3D.Type]  # value = <Type.kSegment3D: 1>
        kTriangle: typing.ClassVar[Primitive3D.Type]  # value = <Type.kTriangle: 4>
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    id: int
    def is_inside(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> bool:
        ...
    @property
    def type(self) -> Primitive3D.Type:
        ...
class PyObjectOccupancyOctreeD(AbstractOccupancyOctreeD):
    class BatchRayCaster:
        def step(self, max_depth: numpy.ndarray[bool[m, 1]] = 0) -> PyObjectOccupancyOctreeD.BatchRayCaster:
            ...
        @property
        def ever_hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def frontier_keys(self) -> list[OctreeKey]:
            ...
        @property
        def frontier_nodes(self) -> list[PyObjectOccupancyOctreeNode]:
            ...
        @property
        def frontier_ray_indices(self) -> list[list[int]]:
            ...
        @property
        def hit_distances(self) -> numpy.ndarray[numpy.float64[m, 1]]:
            ...
        @property
        def hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def hit_nodes(self) -> list[PyObjectOccupancyOctreeNode]:
            ...
        @property
        def hit_positions(self) -> list[numpy.ndarray[numpy.float64[3, 1]]]:
            ...
        @property
        def num_rays(self) -> int:
            ...
        @property
        def ray_directions(self) -> numpy.ndarray[numpy.float64[3, n]]:
            ...
        @property
        def ray_origins(self) -> numpy.ndarray[numpy.float64[3, n]]:
            ...
    class BottomLeafNeighborIterator(PyObjectOccupancyOctreeD.IteratorBase):
        pass
    class Drawer:
        @staticmethod
        def Setting() -> OccupancyOctreeDrawerSetting:
            ...
        def __init__(self, setting: OccupancyOctreeDrawerSetting, octree: PyObjectOccupancyOctreeD = None) -> None:
            ...
        @typing.overload
        def draw_leaves(self) -> list[...]:
            ...
        @typing.overload
        def draw_leaves(self, filename: str) -> None:
            ...
        @typing.overload
        def draw_tree(self) -> list[...]:
            ...
        @typing.overload
        def draw_tree(self, filename: str) -> None:
            ...
        def set_draw_leaf_callback(self, callback: typing.Callable[[PyObjectOccupancyOctreeD.Drawer, list[...], PyObjectOccupancyOctreeD.LeafInAabbIterator], None]) -> None:
            ...
        def set_draw_tree_callback(self, callback: typing.Callable[[PyObjectOccupancyOctreeD.Drawer, list[...], PyObjectOccupancyOctreeD.TreeInAabbIterator], None]) -> None:
            ...
        @property
        def setting(self) -> OccupancyOctreeDrawerSetting:
            ...
    class EastLeafNeighborIterator(PyObjectOccupancyOctreeD.IteratorBase):
        pass
    class IteratorBase(AbstractOctreeD.OctreeNodeIterator):
        __hash__: typing.ClassVar[None] = None
        def __eq__(self, arg0: PyObjectOccupancyOctreeD.IteratorBase) -> bool:
            ...
        def __ne__(self, arg0: PyObjectOccupancyOctreeD.IteratorBase) -> bool:
            ...
        @property
        def index_key(self) -> OctreeKey:
            ...
        @property
        def key(self) -> OctreeKey:
            ...
        @property
        def node(self) -> PyObjectOccupancyOctreeNode:
            ...
        @property
        def node_aabb(self) -> Aabb3Dd:
            ...
    class LeafInAabbIterator(PyObjectOccupancyOctreeD.IteratorBase):
        pass
    class LeafIterator(PyObjectOccupancyOctreeD.IteratorBase):
        pass
    class LeafOfNodeIterator(PyObjectOccupancyOctreeD.IteratorBase):
        pass
    class NodeOnRayIterator(PyObjectOccupancyOctreeD.IteratorBase):
        @property
        def distance(self) -> float:
            ...
    class NorthLeafNeighborIterator(PyObjectOccupancyOctreeD.IteratorBase):
        pass
    class SouthLeafNeighborIterator(PyObjectOccupancyOctreeD.IteratorBase):
        pass
    class TopLeafNeighborIterator(PyObjectOccupancyOctreeD.IteratorBase):
        pass
    class TreeInAabbIterator(PyObjectOccupancyOctreeD.IteratorBase):
        pass
    class TreeIterator(PyObjectOccupancyOctreeD.IteratorBase):
        pass
    class WestLeafNeighborIterator(PyObjectOccupancyOctreeD.IteratorBase):
        pass
    @staticmethod
    def Setting() -> OccupancyOctreeBaseSetting:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, setting: OccupancyOctreeBaseSetting) -> None:
        ...
    @typing.overload
    def __init__(self, filename: str) -> None:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: int, depth: int) -> int:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: OctreeKey, depth: int) -> OctreeKey:
        ...
    def cast_ray(self, px: float, py: float, pz: float, vx: float, vy: float, vz: float, ignore_unknown: bool, max_range: float) -> dict:
        ...
    @typing.overload
    def cast_rays(self, position: numpy.ndarray[numpy.float64[3, 1]], rotation: numpy.ndarray[numpy.float64[3, 3], numpy.ndarray.flags.f_contiguous], azimuth_angles: numpy.ndarray[numpy.float64[m, 1]], elevation_angles: numpy.ndarray[numpy.float64[m, 1]], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    @typing.overload
    def cast_rays(self, positions: numpy.ndarray[numpy.float64[3, n], numpy.ndarray.flags.f_contiguous], directions: numpy.ndarray[numpy.float64[3, n], numpy.ndarray.flags.f_contiguous], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    def clear(self) -> None:
        ...
    def compute_bottom_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_common_ancestor_key(self, arg0: OctreeKey, arg1: OctreeKey) -> tuple[OctreeKey, int]:
        ...
    def compute_east_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_north_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_ray_coords(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float) -> list[numpy.ndarray[numpy.float64[3, 1]]] | None:
        ...
    def compute_ray_keys(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float) -> list[OctreeKey] | None:
        ...
    def compute_south_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_top_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_west_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float) -> int:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float, depth: int) -> int:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, z: float) -> OctreeKey:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, z: float, depth: int) -> OctreeKey:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float, depth: int) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, z: float) -> OctreeKey | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, z: float, depth: int) -> OctreeKey | None:
        ...
    def create_node_child(self, node: PyObjectOccupancyOctreeNode, child_idx: int) -> PyObjectOccupancyOctreeNode:
        ...
    @typing.overload
    def delete_node(self, x: float, y: float, z: float, depth: int) -> int:
        ...
    @typing.overload
    def delete_node(self, key: OctreeKey, depth: int) -> None:
        ...
    def delete_node_child(self, node: PyObjectOccupancyOctreeNode, child_idx: int, key: OctreeKey) -> int:
        ...
    def expand(self) -> None:
        ...
    def expand_node(self, node: PyObjectOccupancyOctreeNode) -> None:
        ...
    def get_batch_ray_caster(self, origins: numpy.ndarray[numpy.float64[3, n]], directions: numpy.ndarray[numpy.float64[3, n]], max_ranges: numpy.ndarray[numpy.float64[m, 1]] = ..., node_paddings: numpy.ndarray[numpy.float64[m, 1]] = ..., bidirectional_flags: numpy.ndarray[bool[m, 1]] = ..., leaf_only_flags: numpy.ndarray[bool[m, 1]] = ..., min_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ..., max_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ...) -> ...:
        ...
    def get_node_child(self, node: PyObjectOccupancyOctreeNode, child_idx: int) -> PyObjectOccupancyOctreeNode:
        ...
    def get_node_size(self, depth: int) -> float:
        ...
    @typing.overload
    def insert_node(self, x: float, y: float, z: float, depth: int) -> PyObjectOccupancyOctreeNode:
        ...
    @typing.overload
    def insert_node(self, key: OctreeKey, depth: int) -> PyObjectOccupancyOctreeNode:
        ...
    def insert_point_cloud(self, points: numpy.ndarray[numpy.float64[3, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float64[3, 1]], min_range: float, max_range: float, with_count: bool, parallel: bool, lazy_eval: bool, discrete: bool) -> None:
        ...
    def insert_point_cloud_rays(self, points: numpy.ndarray[numpy.float64[3, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float64[3, 1]], min_range: float, max_range: float, parallel: bool, lazy_eval: bool) -> None:
        ...
    def insert_ray(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float, min_range: float, max_range: float, lazy_eval: bool) -> bool:
        ...
    def is_node_collapsible(self, node: PyObjectOccupancyOctreeNode) -> bool:
        ...
    @typing.overload
    def iter_bottom_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.BottomLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_bottom_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.BottomLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.EastLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.EastLeafNeighborIterator]:
        ...
    def iter_leaf(self, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.LeafIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_min_z: float, aabb_max_x: float, aabb_max_y: float, aabb_max_z: float, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.LeafInAabbIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_key: OctreeKey, aabb_max_key: OctreeKey, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.LeafInAabbIterator]:
        ...
    def iter_leaf_of_node(self, node_key: OctreeKey, node_depth: int, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.LeafOfNodeIterator]:
        ...
    def iter_node(self, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.TreeIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_min_z: float, aabb_max_x: float, aabb_max_y: float, aabb_max_z: float, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.TreeInAabbIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_key: OctreeKey, aabb_max_key: OctreeKey, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.TreeInAabbIterator]:
        ...
    def iter_node_on_ray(self, px: float, py: float, pz: float, vx: float, vy: float, vz: float, max_range: float = -1, node_padding: float = 0, bidirectional: bool = False, leaf_only: bool = True, min_node_depth: int = 0, max_node_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.NodeOnRayIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_top_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.TopLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_top_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.TopLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeD.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def key_to_coord(self, key: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: int, depth: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: OctreeKey) -> tuple[float, float, float]:
        ...
    @typing.overload
    def key_to_coord(self, key: OctreeKey, depth: int) -> tuple[float, float, float]:
        ...
    def prune(self) -> None:
        ...
    def prune_node(self, node: PyObjectOccupancyOctreeNode) -> bool:
        ...
    def sample_positions(self, num_positions: int) -> list[numpy.ndarray[numpy.float64[3, 1]]]:
        ...
    @typing.overload
    def search(self, x: float, y: float, z: float, max_depth: int = 0) -> PyObjectOccupancyOctreeNode:
        ...
    @typing.overload
    def search(self, key: OctreeKey, max_depth: int = 0) -> PyObjectOccupancyOctreeNode:
        ...
    def to_max_likelihood(self) -> None:
        ...
    def update_inner_occupancy(self) -> None:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, z: float, occupied: bool, lazy_eval: bool) -> PyObjectOccupancyOctreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: OctreeKey, occupied: bool, lazy_eval: bool) -> PyObjectOccupancyOctreeNode:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, z: float, log_odds_delta: float, lazy_eval: bool) -> PyObjectOccupancyOctreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: OctreeKey, log_odds_delta: float, lazy_eval: bool) -> PyObjectOccupancyOctreeNode:
        ...
    def visualize(self, leaf_only: bool = False, scaling: float = 1.0, area_min: numpy.ndarray[numpy.float64[3, 1]] = ..., area_max: numpy.ndarray[numpy.float64[3, 1]] = ..., border_color: numpy.ndarray[numpy.float64[3, 1]] = ..., occupied_color: numpy.ndarray[numpy.float64[3, 1]] = ..., occupied_only: bool = False, draw_node_boxes: bool = True, draw_node_borders: bool = True, window_width: int = 1920, window_height: int = 1080, window_left: int = 50, window_top: int = 50) -> None:
        ...
    @property
    def memory_usage(self) -> int:
        ...
    @property
    def memory_usage_per_node(self) -> int:
        ...
    @property
    def metric_aabb(self) -> Aabb3Dd:
        ...
    @property
    def metric_max(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def metric_min(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def metric_min_max(self) -> tuple[numpy.ndarray[numpy.float64[3, 1]], numpy.ndarray[numpy.float64[3, 1]]]:
        ...
    @property
    def metric_size(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def number_of_leaf_nodes(self) -> int:
        ...
    @property
    def number_of_nodes(self) -> int:
        ...
    @property
    def resolution(self) -> float:
        ...
    @property
    def root(self) -> PyObjectOccupancyOctreeNode:
        ...
    @property
    def setting(self) -> OccupancyOctreeBaseSetting:
        ...
    @property
    def tree_center(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def tree_center_key(self) -> OctreeKey:
        ...
    @property
    def tree_depth(self) -> int:
        ...
    @property
    def tree_max_half_size(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class PyObjectOccupancyOctreeF(AbstractOccupancyOctreeF):
    class BatchRayCaster:
        def step(self, max_depth: numpy.ndarray[bool[m, 1]] = 0) -> PyObjectOccupancyOctreeF.BatchRayCaster:
            ...
        @property
        def ever_hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def frontier_keys(self) -> list[OctreeKey]:
            ...
        @property
        def frontier_nodes(self) -> list[PyObjectOccupancyOctreeNode]:
            ...
        @property
        def frontier_ray_indices(self) -> list[list[int]]:
            ...
        @property
        def hit_distances(self) -> numpy.ndarray[numpy.float32[m, 1]]:
            ...
        @property
        def hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def hit_nodes(self) -> list[PyObjectOccupancyOctreeNode]:
            ...
        @property
        def hit_positions(self) -> list[numpy.ndarray[numpy.float32[3, 1]]]:
            ...
        @property
        def num_rays(self) -> int:
            ...
        @property
        def ray_directions(self) -> numpy.ndarray[numpy.float32[3, n]]:
            ...
        @property
        def ray_origins(self) -> numpy.ndarray[numpy.float32[3, n]]:
            ...
    class BottomLeafNeighborIterator(PyObjectOccupancyOctreeF.IteratorBase):
        pass
    class Drawer:
        @staticmethod
        def Setting() -> OccupancyOctreeDrawerSetting:
            ...
        def __init__(self, setting: OccupancyOctreeDrawerSetting, octree: PyObjectOccupancyOctreeF = None) -> None:
            ...
        @typing.overload
        def draw_leaves(self) -> list[...]:
            ...
        @typing.overload
        def draw_leaves(self, filename: str) -> None:
            ...
        @typing.overload
        def draw_tree(self) -> list[...]:
            ...
        @typing.overload
        def draw_tree(self, filename: str) -> None:
            ...
        def set_draw_leaf_callback(self, callback: typing.Callable[[PyObjectOccupancyOctreeF.Drawer, list[...], PyObjectOccupancyOctreeF.LeafInAabbIterator], None]) -> None:
            ...
        def set_draw_tree_callback(self, callback: typing.Callable[[PyObjectOccupancyOctreeF.Drawer, list[...], PyObjectOccupancyOctreeF.TreeInAabbIterator], None]) -> None:
            ...
        @property
        def setting(self) -> OccupancyOctreeDrawerSetting:
            ...
    class EastLeafNeighborIterator(PyObjectOccupancyOctreeF.IteratorBase):
        pass
    class IteratorBase(AbstractOctreeF.OctreeNodeIterator):
        __hash__: typing.ClassVar[None] = None
        def __eq__(self, arg0: PyObjectOccupancyOctreeF.IteratorBase) -> bool:
            ...
        def __ne__(self, arg0: PyObjectOccupancyOctreeF.IteratorBase) -> bool:
            ...
        @property
        def index_key(self) -> OctreeKey:
            ...
        @property
        def key(self) -> OctreeKey:
            ...
        @property
        def node(self) -> PyObjectOccupancyOctreeNode:
            ...
        @property
        def node_aabb(self) -> Aabb3Df:
            ...
    class LeafInAabbIterator(PyObjectOccupancyOctreeF.IteratorBase):
        pass
    class LeafIterator(PyObjectOccupancyOctreeF.IteratorBase):
        pass
    class LeafOfNodeIterator(PyObjectOccupancyOctreeF.IteratorBase):
        pass
    class NodeOnRayIterator(PyObjectOccupancyOctreeF.IteratorBase):
        @property
        def distance(self) -> float:
            ...
    class NorthLeafNeighborIterator(PyObjectOccupancyOctreeF.IteratorBase):
        pass
    class SouthLeafNeighborIterator(PyObjectOccupancyOctreeF.IteratorBase):
        pass
    class TopLeafNeighborIterator(PyObjectOccupancyOctreeF.IteratorBase):
        pass
    class TreeInAabbIterator(PyObjectOccupancyOctreeF.IteratorBase):
        pass
    class TreeIterator(PyObjectOccupancyOctreeF.IteratorBase):
        pass
    class WestLeafNeighborIterator(PyObjectOccupancyOctreeF.IteratorBase):
        pass
    @staticmethod
    def Setting() -> OccupancyOctreeBaseSetting:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, setting: OccupancyOctreeBaseSetting) -> None:
        ...
    @typing.overload
    def __init__(self, filename: str) -> None:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: int, depth: int) -> int:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: OctreeKey, depth: int) -> OctreeKey:
        ...
    def cast_ray(self, px: float, py: float, pz: float, vx: float, vy: float, vz: float, ignore_unknown: bool, max_range: float) -> dict:
        ...
    @typing.overload
    def cast_rays(self, position: numpy.ndarray[numpy.float32[3, 1]], rotation: numpy.ndarray[numpy.float32[3, 3], numpy.ndarray.flags.f_contiguous], azimuth_angles: numpy.ndarray[numpy.float32[m, 1]], elevation_angles: numpy.ndarray[numpy.float32[m, 1]], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    @typing.overload
    def cast_rays(self, positions: numpy.ndarray[numpy.float32[3, n], numpy.ndarray.flags.f_contiguous], directions: numpy.ndarray[numpy.float32[3, n], numpy.ndarray.flags.f_contiguous], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    def clear(self) -> None:
        ...
    def compute_bottom_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_common_ancestor_key(self, arg0: OctreeKey, arg1: OctreeKey) -> tuple[OctreeKey, int]:
        ...
    def compute_east_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_north_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_ray_coords(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float) -> list[numpy.ndarray[numpy.float32[3, 1]]] | None:
        ...
    def compute_ray_keys(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float) -> list[OctreeKey] | None:
        ...
    def compute_south_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_top_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_west_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float) -> int:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float, depth: int) -> int:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, z: float) -> OctreeKey:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, z: float, depth: int) -> OctreeKey:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float, depth: int) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, z: float) -> OctreeKey | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, z: float, depth: int) -> OctreeKey | None:
        ...
    def create_node_child(self, node: PyObjectOccupancyOctreeNode, child_idx: int) -> PyObjectOccupancyOctreeNode:
        ...
    @typing.overload
    def delete_node(self, x: float, y: float, z: float, depth: int) -> int:
        ...
    @typing.overload
    def delete_node(self, key: OctreeKey, depth: int) -> None:
        ...
    def delete_node_child(self, node: PyObjectOccupancyOctreeNode, child_idx: int, key: OctreeKey) -> int:
        ...
    def expand(self) -> None:
        ...
    def expand_node(self, node: PyObjectOccupancyOctreeNode) -> None:
        ...
    def get_batch_ray_caster(self, origins: numpy.ndarray[numpy.float32[3, n]], directions: numpy.ndarray[numpy.float32[3, n]], max_ranges: numpy.ndarray[numpy.float32[m, 1]] = ..., node_paddings: numpy.ndarray[numpy.float32[m, 1]] = ..., bidirectional_flags: numpy.ndarray[bool[m, 1]] = ..., leaf_only_flags: numpy.ndarray[bool[m, 1]] = ..., min_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ..., max_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ...) -> ...:
        ...
    def get_node_child(self, node: PyObjectOccupancyOctreeNode, child_idx: int) -> PyObjectOccupancyOctreeNode:
        ...
    def get_node_size(self, depth: int) -> float:
        ...
    @typing.overload
    def insert_node(self, x: float, y: float, z: float, depth: int) -> PyObjectOccupancyOctreeNode:
        ...
    @typing.overload
    def insert_node(self, key: OctreeKey, depth: int) -> PyObjectOccupancyOctreeNode:
        ...
    def insert_point_cloud(self, points: numpy.ndarray[numpy.float32[3, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float32[3, 1]], min_range: float, max_range: float, with_count: bool, parallel: bool, lazy_eval: bool, discrete: bool) -> None:
        ...
    def insert_point_cloud_rays(self, points: numpy.ndarray[numpy.float32[3, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float32[3, 1]], min_range: float, max_range: float, parallel: bool, lazy_eval: bool) -> None:
        ...
    def insert_ray(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float, min_range: float, max_range: float, lazy_eval: bool) -> bool:
        ...
    def is_node_collapsible(self, node: PyObjectOccupancyOctreeNode) -> bool:
        ...
    @typing.overload
    def iter_bottom_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.BottomLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_bottom_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.BottomLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.EastLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.EastLeafNeighborIterator]:
        ...
    def iter_leaf(self, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.LeafIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_min_z: float, aabb_max_x: float, aabb_max_y: float, aabb_max_z: float, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.LeafInAabbIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_key: OctreeKey, aabb_max_key: OctreeKey, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.LeafInAabbIterator]:
        ...
    def iter_leaf_of_node(self, node_key: OctreeKey, node_depth: int, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.LeafOfNodeIterator]:
        ...
    def iter_node(self, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.TreeIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_min_z: float, aabb_max_x: float, aabb_max_y: float, aabb_max_z: float, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.TreeInAabbIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_key: OctreeKey, aabb_max_key: OctreeKey, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.TreeInAabbIterator]:
        ...
    def iter_node_on_ray(self, px: float, py: float, pz: float, vx: float, vy: float, vz: float, max_range: float = -1, node_padding: float = 0, bidirectional: bool = False, leaf_only: bool = True, min_node_depth: int = 0, max_node_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.NodeOnRayIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_top_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.TopLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_top_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.TopLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyOctreeF.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def key_to_coord(self, key: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: int, depth: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: OctreeKey) -> tuple[float, float, float]:
        ...
    @typing.overload
    def key_to_coord(self, key: OctreeKey, depth: int) -> tuple[float, float, float]:
        ...
    def prune(self) -> None:
        ...
    def prune_node(self, node: PyObjectOccupancyOctreeNode) -> bool:
        ...
    def sample_positions(self, num_positions: int) -> list[numpy.ndarray[numpy.float32[3, 1]]]:
        ...
    @typing.overload
    def search(self, x: float, y: float, z: float, max_depth: int = 0) -> PyObjectOccupancyOctreeNode:
        ...
    @typing.overload
    def search(self, key: OctreeKey, max_depth: int = 0) -> PyObjectOccupancyOctreeNode:
        ...
    def to_max_likelihood(self) -> None:
        ...
    def update_inner_occupancy(self) -> None:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, z: float, occupied: bool, lazy_eval: bool) -> PyObjectOccupancyOctreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: OctreeKey, occupied: bool, lazy_eval: bool) -> PyObjectOccupancyOctreeNode:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, z: float, log_odds_delta: float, lazy_eval: bool) -> PyObjectOccupancyOctreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: OctreeKey, log_odds_delta: float, lazy_eval: bool) -> PyObjectOccupancyOctreeNode:
        ...
    def visualize(self, leaf_only: bool = False, scaling: float = 1.0, area_min: numpy.ndarray[numpy.float64[3, 1]] = ..., area_max: numpy.ndarray[numpy.float64[3, 1]] = ..., border_color: numpy.ndarray[numpy.float64[3, 1]] = ..., occupied_color: numpy.ndarray[numpy.float64[3, 1]] = ..., occupied_only: bool = False, draw_node_boxes: bool = True, draw_node_borders: bool = True, window_width: int = 1920, window_height: int = 1080, window_left: int = 50, window_top: int = 50) -> None:
        ...
    @property
    def memory_usage(self) -> int:
        ...
    @property
    def memory_usage_per_node(self) -> int:
        ...
    @property
    def metric_aabb(self) -> Aabb3Df:
        ...
    @property
    def metric_max(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def metric_min(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def metric_min_max(self) -> tuple[numpy.ndarray[numpy.float32[3, 1]], numpy.ndarray[numpy.float32[3, 1]]]:
        ...
    @property
    def metric_size(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def number_of_leaf_nodes(self) -> int:
        ...
    @property
    def number_of_nodes(self) -> int:
        ...
    @property
    def resolution(self) -> float:
        ...
    @property
    def root(self) -> PyObjectOccupancyOctreeNode:
        ...
    @property
    def setting(self) -> OccupancyOctreeBaseSetting:
        ...
    @property
    def tree_center(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def tree_center_key(self) -> OctreeKey:
        ...
    @property
    def tree_depth(self) -> int:
        ...
    @property
    def tree_max_half_size(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
class PyObjectOccupancyOctreeNode(AbstractOctreeNode):
    py_object: typing.Any
    def add_log_odds(self, log_odds: float) -> None:
        ...
    def allow_update_log_odds(self, delta: float) -> bool:
        ...
    def get_child(self, child_idx: int) -> PyObjectOccupancyOctreeNode:
        ...
    @property
    def log_odds(self) -> float:
        ...
    @property
    def max_child_log_odds(self) -> float:
        ...
    @property
    def mean_child_log_odds(self) -> float:
        ...
    @property
    def occupancy(self) -> float:
        ...
class PyObjectOccupancyQuadtreeD(AbstractOccupancyQuadtreeD):
    class BatchRayCaster:
        def step(self, mask: numpy.ndarray[bool[m, 1]] = ...) -> PyObjectOccupancyQuadtreeD.BatchRayCaster:
            ...
        @property
        def ever_hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def frontier_keys(self) -> list[QuadtreeKey]:
            ...
        @property
        def frontier_nodes(self) -> list[PyObjectOccupancyQuadtreeNode]:
            ...
        @property
        def frontier_ray_indices(self) -> list[list[int]]:
            ...
        @property
        def hit_distances(self) -> numpy.ndarray[numpy.float64[m, 1]]:
            ...
        @property
        def hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def hit_nodes(self) -> list[PyObjectOccupancyQuadtreeNode]:
            ...
        @property
        def hit_positions(self) -> list[numpy.ndarray[numpy.float64[2, 1]]]:
            ...
        @property
        def num_rays(self) -> int:
            ...
        @property
        def ray_directions(self) -> numpy.ndarray[numpy.float64[2, n]]:
            ...
        @property
        def ray_origins(self) -> numpy.ndarray[numpy.float64[2, n]]:
            ...
    class Drawer:
        @staticmethod
        def Setting() -> OccupancyQuadtreeDrawerSettingD:
            ...
        def __init__(self, setting: OccupancyQuadtreeDrawerSettingD, quadtree: PyObjectOccupancyQuadtreeD = None) -> None:
            ...
        @typing.overload
        def draw_leaves(self) -> Mat:
            ...
        @typing.overload
        def draw_leaves(self, filename: str) -> None:
            ...
        @typing.overload
        def draw_tree(self) -> Mat:
            ...
        @typing.overload
        def draw_tree(self, filename: str) -> None:
            ...
        def set_draw_leaf_callback(self, callback: typing.Callable[[PyObjectOccupancyQuadtreeD.Drawer, Mat, PyObjectOccupancyQuadtreeD.LeafIterator], None]) -> None:
            ...
        def set_draw_tree_callback(self, callback: typing.Callable[[PyObjectOccupancyQuadtreeD.Drawer, Mat, PyObjectOccupancyQuadtreeD.TreeIterator], None]) -> None:
            ...
        @property
        def grid_map_info(self) -> ...:
            ...
        @property
        def setting(self) -> OccupancyQuadtreeDrawerSettingD:
            ...
    class EastLeafNeighborIterator(PyObjectOccupancyQuadtreeD.IteratorBase):
        pass
    class IteratorBase(AbstractQuadtreeD.QuadtreeNodeIterator):
        __hash__: typing.ClassVar[None] = None
        def __eq__(self, arg0: PyObjectOccupancyQuadtreeD.IteratorBase) -> bool:
            ...
        def __ne__(self, arg0: PyObjectOccupancyQuadtreeD.IteratorBase) -> bool:
            ...
        @property
        def index_key(self) -> QuadtreeKey:
            ...
        @property
        def key(self) -> QuadtreeKey:
            ...
        @property
        def node(self) -> PyObjectOccupancyQuadtreeNode:
            ...
        @property
        def node_aabb(self) -> Aabb2Dd:
            ...
    class LeafInAabbIterator(PyObjectOccupancyQuadtreeD.IteratorBase):
        pass
    class LeafIterator(PyObjectOccupancyQuadtreeD.IteratorBase):
        pass
    class LeafOfNodeIterator(PyObjectOccupancyQuadtreeD.IteratorBase):
        pass
    class NodeOnRayIterator(PyObjectOccupancyQuadtreeD.IteratorBase):
        @property
        def distance(self) -> float:
            ...
    class NorthLeafNeighborIterator(PyObjectOccupancyQuadtreeD.IteratorBase):
        pass
    class SouthLeafNeighborIterator(PyObjectOccupancyQuadtreeD.IteratorBase):
        pass
    class TreeInAabbIterator(PyObjectOccupancyQuadtreeD.IteratorBase):
        pass
    class TreeIterator(PyObjectOccupancyQuadtreeD.IteratorBase):
        pass
    class WestLeafNeighborIterator(PyObjectOccupancyQuadtreeD.IteratorBase):
        pass
    @staticmethod
    def Setting() -> OccupancyQuadtreeBaseSetting:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, setting: OccupancyQuadtreeBaseSetting) -> None:
        ...
    @typing.overload
    def __init__(self, filename: str) -> None:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: int, depth: int) -> int:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: QuadtreeKey, depth: int) -> QuadtreeKey:
        ...
    def cast_ray(self, px: float, py: float, vx: float, vy: float, ignore_unknown: bool, max_range: float) -> dict:
        ...
    @typing.overload
    def cast_rays(self, position: numpy.ndarray[numpy.float64[2, 1]], rotation: numpy.ndarray[numpy.float64[2, 2], numpy.ndarray.flags.f_contiguous], angles: numpy.ndarray[numpy.float64[m, 1]], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    @typing.overload
    def cast_rays(self, positions: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous], directions: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    def clear(self) -> None:
        ...
    def compute_common_ancestor_key(self, arg0: QuadtreeKey, arg1: QuadtreeKey) -> tuple[QuadtreeKey, int]:
        ...
    def compute_east_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_north_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_ray_coords(self, sx: float, sy: float, ex: float, ey: float) -> list[numpy.ndarray[numpy.float64[2, 1]]] | None:
        ...
    def compute_ray_keys(self, sx: float, sy: float, ex: float, ey: float) -> list[QuadtreeKey] | None:
        ...
    def compute_south_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_west_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float) -> int:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float, depth: int) -> int:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float) -> QuadtreeKey:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, depth: int) -> QuadtreeKey:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float, depth: int) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float) -> QuadtreeKey | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, depth: int) -> QuadtreeKey | None:
        ...
    def create_node_child(self, node: PyObjectOccupancyQuadtreeNode, child_idx: int) -> PyObjectOccupancyQuadtreeNode:
        ...
    @typing.overload
    def delete_node(self, x: float, y: float, depth: int) -> int:
        ...
    @typing.overload
    def delete_node(self, key: QuadtreeKey, depth: int) -> None:
        ...
    def delete_node_child(self, node: PyObjectOccupancyQuadtreeNode, child_idx: int, key: QuadtreeKey) -> int:
        ...
    def expand(self) -> None:
        ...
    def expand_node(self, node: PyObjectOccupancyQuadtreeNode) -> None:
        ...
    def get_batch_ray_caster(self, origins: numpy.ndarray[numpy.float64[2, n]], directions: numpy.ndarray[numpy.float64[2, n]], max_ranges: numpy.ndarray[numpy.float64[m, 1]] = ..., node_paddings: numpy.ndarray[numpy.float64[m, 1]] = ..., bidirectional_flags: numpy.ndarray[bool[m, 1]] = ..., leaf_only_flags: numpy.ndarray[bool[m, 1]] = ..., min_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ..., max_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ...) -> ...:
        ...
    def get_node_child(self, node: PyObjectOccupancyQuadtreeNode, child_idx: int) -> PyObjectOccupancyQuadtreeNode:
        ...
    def get_node_size(self, depth: int) -> float:
        ...
    @typing.overload
    def insert_node(self, x: float, y: float, depth: int) -> PyObjectOccupancyQuadtreeNode:
        ...
    @typing.overload
    def insert_node(self, key: QuadtreeKey, depth: int) -> PyObjectOccupancyQuadtreeNode:
        ...
    def insert_point_cloud(self, points: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float64[2, 1]], min_range: float, max_range: float, with_count: bool, parallel: bool, lazy_eval: bool, discrete: bool) -> None:
        ...
    def insert_point_cloud_rays(self, points: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float64[2, 1]], min_range: float, max_range: float, parallel: bool, lazy_eval: bool) -> None:
        ...
    def insert_ray(self, sx: float, sy: float, ex: float, ey: float, min_range: float, max_range: float, lazy_eval: bool) -> bool:
        ...
    def is_node_collapsible(self, node: PyObjectOccupancyQuadtreeNode) -> bool:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.EastLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.EastLeafNeighborIterator]:
        ...
    def iter_leaf(self, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.LeafIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_max_x: float, aabb_max_y: float, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.LeafInAabbIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_key: QuadtreeKey, aabb_max_key: QuadtreeKey, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.LeafInAabbIterator]:
        ...
    def iter_leaf_of_node(self, node_key: QuadtreeKey, node_depth: int, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.LeafOfNodeIterator]:
        ...
    def iter_node(self, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.TreeIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_max_x: float, aabb_max_y: float, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.TreeInAabbIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_key: QuadtreeKey, aabb_max_key: QuadtreeKey, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.TreeInAabbIterator]:
        ...
    def iter_node_on_ray(self, px: float, py: float, vx: float, vy: float, max_range: float = -1, node_padding: float = 0, bidirectional: bool = False, leaf_only: bool = False, min_node_depth: int = 0, max_node_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.NodeOnRayIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeD.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def key_to_coord(self, key: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: int, depth: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: QuadtreeKey) -> tuple[float, float]:
        ...
    @typing.overload
    def key_to_coord(self, key: QuadtreeKey, depth: int) -> tuple[float, float]:
        ...
    def prune(self) -> None:
        ...
    def prune_node(self, node: PyObjectOccupancyQuadtreeNode) -> bool:
        ...
    def sample_positions(self, num_positions: int) -> list[numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    @typing.overload
    def search(self, x: float, y: float, max_depth: int = 0) -> PyObjectOccupancyQuadtreeNode:
        ...
    @typing.overload
    def search(self, key: QuadtreeKey, max_depth: int = 0) -> PyObjectOccupancyQuadtreeNode:
        ...
    def to_max_likelihood(self) -> None:
        ...
    def update_inner_occupancy(self) -> None:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, occupied: bool, lazy_eval: bool) -> PyObjectOccupancyQuadtreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: QuadtreeKey, occupied: bool, lazy_eval: bool) -> PyObjectOccupancyQuadtreeNode:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, log_odds_delta: float, lazy_eval: bool) -> PyObjectOccupancyQuadtreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: QuadtreeKey, log_odds_delta: float, lazy_eval: bool) -> PyObjectOccupancyQuadtreeNode:
        ...
    def visualize(self, leaf_only: bool = False, area_min: numpy.ndarray[numpy.float32[2, 1]] | None = None, area_max: numpy.ndarray[numpy.float32[2, 1]] | None = None, resolution: float = 0.1, padding: int = 1, bg_color: numpy.ndarray[numpy.int32[4, 1]] = ..., fg_color: numpy.ndarray[numpy.int32[4, 1]] = ..., occupied_color: numpy.ndarray[numpy.int32[4, 1]] = ..., free_color: numpy.ndarray[numpy.int32[4, 1]] = ..., border_color: numpy.ndarray[numpy.int32[4, 1]] = ..., border_thickness: int = 1) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def memory_usage(self) -> int:
        ...
    @property
    def memory_usage_per_node(self) -> int:
        ...
    @property
    def metric_aabb(self) -> Aabb2Dd:
        ...
    @property
    def metric_max(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def metric_min(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def metric_min_max(self) -> tuple[numpy.ndarray[numpy.float64[2, 1]], numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    @property
    def metric_size(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def number_of_leaf_nodes(self) -> int:
        ...
    @property
    def number_of_nodes(self) -> int:
        ...
    @property
    def resolution(self) -> float:
        ...
    @property
    def root(self) -> PyObjectOccupancyQuadtreeNode:
        ...
    @property
    def setting(self) -> OccupancyQuadtreeBaseSetting:
        ...
    @property
    def tree_center(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def tree_center_key(self) -> QuadtreeKey:
        ...
    @property
    def tree_depth(self) -> int:
        ...
    @property
    def tree_max_half_size(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class PyObjectOccupancyQuadtreeF(AbstractOccupancyQuadtreeF):
    class BatchRayCaster:
        def step(self, mask: numpy.ndarray[bool[m, 1]] = ...) -> PyObjectOccupancyQuadtreeF.BatchRayCaster:
            ...
        @property
        def ever_hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def frontier_keys(self) -> list[QuadtreeKey]:
            ...
        @property
        def frontier_nodes(self) -> list[PyObjectOccupancyQuadtreeNode]:
            ...
        @property
        def frontier_ray_indices(self) -> list[list[int]]:
            ...
        @property
        def hit_distances(self) -> numpy.ndarray[numpy.float32[m, 1]]:
            ...
        @property
        def hit_flags(self) -> numpy.ndarray[bool[m, 1]]:
            ...
        @property
        def hit_nodes(self) -> list[PyObjectOccupancyQuadtreeNode]:
            ...
        @property
        def hit_positions(self) -> list[numpy.ndarray[numpy.float32[2, 1]]]:
            ...
        @property
        def num_rays(self) -> int:
            ...
        @property
        def ray_directions(self) -> numpy.ndarray[numpy.float32[2, n]]:
            ...
        @property
        def ray_origins(self) -> numpy.ndarray[numpy.float32[2, n]]:
            ...
    class Drawer:
        @staticmethod
        def Setting() -> OccupancyQuadtreeDrawerSettingF:
            ...
        def __init__(self, setting: OccupancyQuadtreeDrawerSettingF, quadtree: PyObjectOccupancyQuadtreeF = None) -> None:
            ...
        @typing.overload
        def draw_leaves(self) -> Mat:
            ...
        @typing.overload
        def draw_leaves(self, filename: str) -> None:
            ...
        @typing.overload
        def draw_tree(self) -> Mat:
            ...
        @typing.overload
        def draw_tree(self, filename: str) -> None:
            ...
        def set_draw_leaf_callback(self, callback: typing.Callable[[PyObjectOccupancyQuadtreeF.Drawer, Mat, PyObjectOccupancyQuadtreeF.LeafIterator], None]) -> None:
            ...
        def set_draw_tree_callback(self, callback: typing.Callable[[PyObjectOccupancyQuadtreeF.Drawer, Mat, PyObjectOccupancyQuadtreeF.TreeIterator], None]) -> None:
            ...
        @property
        def grid_map_info(self) -> ...:
            ...
        @property
        def setting(self) -> OccupancyQuadtreeDrawerSettingF:
            ...
    class EastLeafNeighborIterator(PyObjectOccupancyQuadtreeF.IteratorBase):
        pass
    class IteratorBase(AbstractQuadtreeF.QuadtreeNodeIterator):
        __hash__: typing.ClassVar[None] = None
        def __eq__(self, arg0: PyObjectOccupancyQuadtreeF.IteratorBase) -> bool:
            ...
        def __ne__(self, arg0: PyObjectOccupancyQuadtreeF.IteratorBase) -> bool:
            ...
        @property
        def index_key(self) -> QuadtreeKey:
            ...
        @property
        def key(self) -> QuadtreeKey:
            ...
        @property
        def node(self) -> PyObjectOccupancyQuadtreeNode:
            ...
        @property
        def node_aabb(self) -> Aabb2Df:
            ...
    class LeafInAabbIterator(PyObjectOccupancyQuadtreeF.IteratorBase):
        pass
    class LeafIterator(PyObjectOccupancyQuadtreeF.IteratorBase):
        pass
    class LeafOfNodeIterator(PyObjectOccupancyQuadtreeF.IteratorBase):
        pass
    class NodeOnRayIterator(PyObjectOccupancyQuadtreeF.IteratorBase):
        @property
        def distance(self) -> float:
            ...
    class NorthLeafNeighborIterator(PyObjectOccupancyQuadtreeF.IteratorBase):
        pass
    class SouthLeafNeighborIterator(PyObjectOccupancyQuadtreeF.IteratorBase):
        pass
    class TreeInAabbIterator(PyObjectOccupancyQuadtreeF.IteratorBase):
        pass
    class TreeIterator(PyObjectOccupancyQuadtreeF.IteratorBase):
        pass
    class WestLeafNeighborIterator(PyObjectOccupancyQuadtreeF.IteratorBase):
        pass
    @staticmethod
    def Setting() -> OccupancyQuadtreeBaseSetting:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, setting: OccupancyQuadtreeBaseSetting) -> None:
        ...
    @typing.overload
    def __init__(self, filename: str) -> None:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: int, depth: int) -> int:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: QuadtreeKey, depth: int) -> QuadtreeKey:
        ...
    def cast_ray(self, px: float, py: float, vx: float, vy: float, ignore_unknown: bool, max_range: float) -> dict:
        ...
    @typing.overload
    def cast_rays(self, position: numpy.ndarray[numpy.float32[2, 1]], rotation: numpy.ndarray[numpy.float32[2, 2], numpy.ndarray.flags.f_contiguous], angles: numpy.ndarray[numpy.float32[m, 1]], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    @typing.overload
    def cast_rays(self, positions: numpy.ndarray[numpy.float32[2, n], numpy.ndarray.flags.f_contiguous], directions: numpy.ndarray[numpy.float32[2, n], numpy.ndarray.flags.f_contiguous], ignore_unknown: bool, max_range: float, prune_rays: bool, parallel: bool) -> dict:
        ...
    def clear(self) -> None:
        ...
    def compute_common_ancestor_key(self, arg0: QuadtreeKey, arg1: QuadtreeKey) -> tuple[QuadtreeKey, int]:
        ...
    def compute_east_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_north_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_ray_coords(self, sx: float, sy: float, ex: float, ey: float) -> list[numpy.ndarray[numpy.float32[2, 1]]] | None:
        ...
    def compute_ray_keys(self, sx: float, sy: float, ex: float, ey: float) -> list[QuadtreeKey] | None:
        ...
    def compute_south_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_west_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float) -> int:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float, depth: int) -> int:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float) -> QuadtreeKey:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, depth: int) -> QuadtreeKey:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float, depth: int) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float) -> QuadtreeKey | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, depth: int) -> QuadtreeKey | None:
        ...
    def create_node_child(self, node: PyObjectOccupancyQuadtreeNode, child_idx: int) -> PyObjectOccupancyQuadtreeNode:
        ...
    @typing.overload
    def delete_node(self, x: float, y: float, depth: int) -> int:
        ...
    @typing.overload
    def delete_node(self, key: QuadtreeKey, depth: int) -> None:
        ...
    def delete_node_child(self, node: PyObjectOccupancyQuadtreeNode, child_idx: int, key: QuadtreeKey) -> int:
        ...
    def expand(self) -> None:
        ...
    def expand_node(self, node: PyObjectOccupancyQuadtreeNode) -> None:
        ...
    def get_batch_ray_caster(self, origins: numpy.ndarray[numpy.float32[2, n]], directions: numpy.ndarray[numpy.float32[2, n]], max_ranges: numpy.ndarray[numpy.float32[m, 1]] = ..., node_paddings: numpy.ndarray[numpy.float32[m, 1]] = ..., bidirectional_flags: numpy.ndarray[bool[m, 1]] = ..., leaf_only_flags: numpy.ndarray[bool[m, 1]] = ..., min_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ..., max_node_depths: numpy.ndarray[numpy.int32[m, 1]] = ...) -> ...:
        ...
    def get_node_child(self, node: PyObjectOccupancyQuadtreeNode, child_idx: int) -> PyObjectOccupancyQuadtreeNode:
        ...
    def get_node_size(self, depth: int) -> float:
        ...
    @typing.overload
    def insert_node(self, x: float, y: float, depth: int) -> PyObjectOccupancyQuadtreeNode:
        ...
    @typing.overload
    def insert_node(self, key: QuadtreeKey, depth: int) -> PyObjectOccupancyQuadtreeNode:
        ...
    def insert_point_cloud(self, points: numpy.ndarray[numpy.float32[2, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float32[2, 1]], min_range: float, max_range: float, with_count: bool, parallel: bool, lazy_eval: bool, discrete: bool) -> None:
        ...
    def insert_point_cloud_rays(self, points: numpy.ndarray[numpy.float32[2, n], numpy.ndarray.flags.f_contiguous], sensor_origin: numpy.ndarray[numpy.float32[2, 1]], min_range: float, max_range: float, parallel: bool, lazy_eval: bool) -> None:
        ...
    def insert_ray(self, sx: float, sy: float, ex: float, ey: float, min_range: float, max_range: float, lazy_eval: bool) -> bool:
        ...
    def is_node_collapsible(self, node: PyObjectOccupancyQuadtreeNode) -> bool:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.EastLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.EastLeafNeighborIterator]:
        ...
    def iter_leaf(self, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.LeafIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_max_x: float, aabb_max_y: float, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.LeafInAabbIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_key: QuadtreeKey, aabb_max_key: QuadtreeKey, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.LeafInAabbIterator]:
        ...
    def iter_leaf_of_node(self, node_key: QuadtreeKey, node_depth: int, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.LeafOfNodeIterator]:
        ...
    def iter_node(self, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.TreeIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_max_x: float, aabb_max_y: float, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.TreeInAabbIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_key: QuadtreeKey, aabb_max_key: QuadtreeKey, max_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.TreeInAabbIterator]:
        ...
    def iter_node_on_ray(self, px: float, py: float, vx: float, vy: float, max_range: float = -1, node_padding: float = 0, bidirectional: bool = False, leaf_only: bool = False, min_node_depth: int = 0, max_node_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.NodeOnRayIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[PyObjectOccupancyQuadtreeF.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def key_to_coord(self, key: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: int, depth: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: QuadtreeKey) -> tuple[float, float]:
        ...
    @typing.overload
    def key_to_coord(self, key: QuadtreeKey, depth: int) -> tuple[float, float]:
        ...
    def prune(self) -> None:
        ...
    def prune_node(self, node: PyObjectOccupancyQuadtreeNode) -> bool:
        ...
    def sample_positions(self, num_positions: int) -> list[numpy.ndarray[numpy.float32[2, 1]]]:
        ...
    @typing.overload
    def search(self, x: float, y: float, max_depth: int = 0) -> PyObjectOccupancyQuadtreeNode:
        ...
    @typing.overload
    def search(self, key: QuadtreeKey, max_depth: int = 0) -> PyObjectOccupancyQuadtreeNode:
        ...
    def to_max_likelihood(self) -> None:
        ...
    def update_inner_occupancy(self) -> None:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, occupied: bool, lazy_eval: bool) -> PyObjectOccupancyQuadtreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: QuadtreeKey, occupied: bool, lazy_eval: bool) -> PyObjectOccupancyQuadtreeNode:
        ...
    @typing.overload
    def update_node(self, x: float, y: float, log_odds_delta: float, lazy_eval: bool) -> PyObjectOccupancyQuadtreeNode:
        ...
    @typing.overload
    def update_node(self, node_key: QuadtreeKey, log_odds_delta: float, lazy_eval: bool) -> PyObjectOccupancyQuadtreeNode:
        ...
    def visualize(self, leaf_only: bool = False, area_min: numpy.ndarray[numpy.float32[2, 1]] | None = None, area_max: numpy.ndarray[numpy.float32[2, 1]] | None = None, resolution: float = 0.1, padding: int = 1, bg_color: numpy.ndarray[numpy.int32[4, 1]] = ..., fg_color: numpy.ndarray[numpy.int32[4, 1]] = ..., occupied_color: numpy.ndarray[numpy.int32[4, 1]] = ..., free_color: numpy.ndarray[numpy.int32[4, 1]] = ..., border_color: numpy.ndarray[numpy.int32[4, 1]] = ..., border_thickness: int = 1) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def memory_usage(self) -> int:
        ...
    @property
    def memory_usage_per_node(self) -> int:
        ...
    @property
    def metric_aabb(self) -> Aabb2Df:
        ...
    @property
    def metric_max(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def metric_min(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def metric_min_max(self) -> tuple[numpy.ndarray[numpy.float32[2, 1]], numpy.ndarray[numpy.float32[2, 1]]]:
        ...
    @property
    def metric_size(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def number_of_leaf_nodes(self) -> int:
        ...
    @property
    def number_of_nodes(self) -> int:
        ...
    @property
    def resolution(self) -> float:
        ...
    @property
    def root(self) -> PyObjectOccupancyQuadtreeNode:
        ...
    @property
    def setting(self) -> OccupancyQuadtreeBaseSetting:
        ...
    @property
    def tree_center(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def tree_center_key(self) -> QuadtreeKey:
        ...
    @property
    def tree_depth(self) -> int:
        ...
    @property
    def tree_max_half_size(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
class PyObjectOccupancyQuadtreeNode(AbstractQuadtreeNode):
    py_object: typing.Any
    def add_log_odds(self, log_odds: float) -> None:
        ...
    def allow_update_log_odds(self, delta: float) -> bool:
        ...
    def get_child(self, child_idx: int) -> PyObjectOccupancyQuadtreeNode:
        ...
    @property
    def log_odds(self) -> float:
        ...
    @property
    def max_child_log_odds(self) -> float:
        ...
    @property
    def mean_child_log_odds(self) -> float:
        ...
    @property
    def occupancy(self) -> float:
        ...
class QuadtreeKey:
    def __eq__(self, arg0: QuadtreeKey) -> bool:
        ...
    def __getitem__(self, arg0: int) -> int:
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, a: int, b: int) -> None:
        ...
    def __ne__(self, arg0: QuadtreeKey) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def to_list(self) -> list:
        ...
class RangeSensor3Dd:
    @typing.overload
    def add_mesh(self, mesh_path: str) -> None:
        ...
    @typing.overload
    def add_mesh(self, vertices: numpy.ndarray[numpy.float64[3, n], numpy.ndarray.flags.f_contiguous], triangles: numpy.ndarray[numpy.int32[3, n], numpy.ndarray.flags.f_contiguous]) -> None:
        ...
    @typing.overload
    def add_mesh(self, vertices: list[numpy.ndarray[numpy.float64[3, 1]]], triangles: list[numpy.ndarray[numpy.int32[3, 1]]]) -> None:
        ...
    def scan(self, orientation: numpy.ndarray[numpy.float64[3, 3], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float64[3, 1]], add_noise: bool = False, noise_stddev: float = 0.03, cache_normals: bool = False) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @property
    def cached_normals(self) -> numpy.ndarray[numpy.float64]:
        ...
    @property
    def optical_pose(self, arg1: numpy.ndarray[numpy.float64[3, 3], numpy.ndarray.flags.f_contiguous], arg2: numpy.ndarray[numpy.float64[3, 1]]) -> tuple[numpy.ndarray[numpy.float64[3, 3]], numpy.ndarray[numpy.float64[3, 1]]]:
        ...
    @property
    def ray_directions_in_frame(self) -> numpy.ndarray[numpy.float64]:
        ...
class RangeSensor3Df:
    @typing.overload
    def add_mesh(self, mesh_path: str) -> None:
        ...
    @typing.overload
    def add_mesh(self, vertices: numpy.ndarray[numpy.float32[3, n], numpy.ndarray.flags.f_contiguous], triangles: numpy.ndarray[numpy.int32[3, n], numpy.ndarray.flags.f_contiguous]) -> None:
        ...
    @typing.overload
    def add_mesh(self, vertices: list[numpy.ndarray[numpy.float32[3, 1]]], triangles: list[numpy.ndarray[numpy.int32[3, 1]]]) -> None:
        ...
    def scan(self, orientation: numpy.ndarray[numpy.float32[3, 3], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float32[3, 1]], add_noise: bool = False, noise_stddev: float = 0.03, cache_normals: bool = False) -> numpy.ndarray[numpy.float32[m, n]]:
        ...
    @property
    def cached_normals(self) -> numpy.ndarray[numpy.float64]:
        ...
    @property
    def optical_pose(self, arg1: numpy.ndarray[numpy.float32[3, 3], numpy.ndarray.flags.f_contiguous], arg2: numpy.ndarray[numpy.float32[3, 1]]) -> tuple[numpy.ndarray[numpy.float32[3, 3]], numpy.ndarray[numpy.float32[3, 1]]]:
        ...
    @property
    def ray_directions_in_frame(self) -> numpy.ndarray[numpy.float64]:
        ...
class RangeSensorFrame3Dd:
    class Setting(YamlableBase):
        col_margin: int
        row_margin: int
        valid_range_max: float
        valid_range_min: float
    def compute_closest_end_point(self, position_world: numpy.ndarray[numpy.float64[3, 1]], brute_force: bool = False) -> dict:
        ...
    def compute_frame_coords(self, xyz_frame: numpy.ndarray[numpy.float64[3, 1]]) -> dict:
        ...
    def compute_rays_at(self, position_world: numpy.ndarray[numpy.float64[3, 1]]) -> dict:
        ...
    def coords_is_in_frame(self, frame_coords: numpy.ndarray[numpy.float64[2, 1]]) -> bool:
        ...
    def dir_frame_to_world(self, dir_frame: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def dir_world_to_frame(self, dir_world: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def pos_frame_to_world(self, pos_frame: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def pos_world_to_frame(self, pos_world: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def position_is_in_frame(self, xyz_frame: numpy.ndarray[numpy.float64[3, 1]]) -> bool:
        ...
    @typing.overload
    def sample_along_rays(self, num_samples_per_ray: int, max_in_obstacle_dist: float, sampled_rays_ratio: float) -> dict:
        ...
    @typing.overload
    def sample_along_rays(self, range_step: float, max_in_obstacle_dist: float, sampled_rays_ratio: float) -> dict:
        ...
    def sample_in_region_hpr(self, num_positions: int, num_near_surface_samples_per_ray: int, num_along_ray_samples_per_ray: int, max_in_obstacle_dist: float, parallel: bool) -> dict:
        ...
    def sample_in_region_vrs(self, num_hit_points: int, num_samples_per_azimuth_segment: int, num_azimuth_segments: int, parallel: bool) -> dict:
        ...
    def sample_near_surface(self, num_samples_per_ray: int, max_offset: float, sampled_rays_ratio: float) -> dict:
        ...
    @property
    def end_points_in_frame(self) -> numpy.ndarray[numpy.float64]:
        ...
    @property
    def end_points_in_world(self) -> numpy.ndarray[numpy.float64]:
        ...
    @property
    def frame_coords(self) -> numpy.ndarray[numpy.float64]:
        ...
    @property
    def hit_mask(self) -> numpy.ndarray[bool[m, n]]:
        ...
    @property
    def hit_points_world(self) -> list[numpy.ndarray[numpy.float64[3, 1]]]:
        ...
    @property
    def hit_ray_indices(self) -> list[tuple[int, int]]:
        ...
    @property
    def is_valid(self) -> bool:
        ...
    @property
    def max_valid_range(self) -> float:
        ...
    @property
    def min_valid_range(self) -> float:
        ...
    @property
    def num_hit_rays(self) -> int:
        ...
    @property
    def num_rays(self) -> int:
        ...
    @property
    def pose_matrix(self) -> numpy.ndarray[numpy.float64[4, 4]]:
        ...
    @property
    def ranges(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @property
    def ray_directions_in_frame(self) -> numpy.ndarray[numpy.float64]:
        ...
    @property
    def ray_directions_in_world(self) -> numpy.ndarray[numpy.float64]:
        ...
    @property
    def rotation_matrix(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @property
    def translation_vector(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class RangeSensorFrame3Df:
    class Setting(YamlableBase):
        col_margin: int
        row_margin: int
        valid_range_max: float
        valid_range_min: float
    def compute_closest_end_point(self, position_world: numpy.ndarray[numpy.float32[3, 1]], brute_force: bool = False) -> dict:
        ...
    def compute_frame_coords(self, xyz_frame: numpy.ndarray[numpy.float32[3, 1]]) -> dict:
        ...
    def compute_rays_at(self, position_world: numpy.ndarray[numpy.float32[3, 1]]) -> dict:
        ...
    def coords_is_in_frame(self, frame_coords: numpy.ndarray[numpy.float32[2, 1]]) -> bool:
        ...
    def dir_frame_to_world(self, dir_frame: numpy.ndarray[numpy.float32[3, 1]]) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    def dir_world_to_frame(self, dir_world: numpy.ndarray[numpy.float32[3, 1]]) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    def pos_frame_to_world(self, pos_frame: numpy.ndarray[numpy.float32[3, 1]]) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    def pos_world_to_frame(self, pos_world: numpy.ndarray[numpy.float32[3, 1]]) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    def position_is_in_frame(self, xyz_frame: numpy.ndarray[numpy.float32[3, 1]]) -> bool:
        ...
    @typing.overload
    def sample_along_rays(self, num_samples_per_ray: int, max_in_obstacle_dist: float, sampled_rays_ratio: float) -> dict:
        ...
    @typing.overload
    def sample_along_rays(self, range_step: float, max_in_obstacle_dist: float, sampled_rays_ratio: float) -> dict:
        ...
    def sample_in_region_hpr(self, num_positions: int, num_near_surface_samples_per_ray: int, num_along_ray_samples_per_ray: int, max_in_obstacle_dist: float, parallel: bool) -> dict:
        ...
    def sample_in_region_vrs(self, num_hit_points: int, num_samples_per_azimuth_segment: int, num_azimuth_segments: int, parallel: bool) -> dict:
        ...
    def sample_near_surface(self, num_samples_per_ray: int, max_offset: float, sampled_rays_ratio: float) -> dict:
        ...
    @property
    def end_points_in_frame(self) -> numpy.ndarray[numpy.float32]:
        ...
    @property
    def end_points_in_world(self) -> numpy.ndarray[numpy.float32]:
        ...
    @property
    def frame_coords(self) -> numpy.ndarray[numpy.float32]:
        ...
    @property
    def hit_mask(self) -> numpy.ndarray[bool[m, n]]:
        ...
    @property
    def hit_points_world(self) -> list[numpy.ndarray[numpy.float32[3, 1]]]:
        ...
    @property
    def hit_ray_indices(self) -> list[tuple[int, int]]:
        ...
    @property
    def is_valid(self) -> bool:
        ...
    @property
    def max_valid_range(self) -> float:
        ...
    @property
    def min_valid_range(self) -> float:
        ...
    @property
    def num_hit_rays(self) -> int:
        ...
    @property
    def num_rays(self) -> int:
        ...
    @property
    def pose_matrix(self) -> numpy.ndarray[numpy.float32[4, 4]]:
        ...
    @property
    def ranges(self) -> numpy.ndarray[numpy.float32[m, n]]:
        ...
    @property
    def ray_directions_in_frame(self) -> numpy.ndarray[numpy.float32]:
        ...
    @property
    def ray_directions_in_world(self) -> numpy.ndarray[numpy.float32]:
        ...
    @property
    def rotation_matrix(self) -> numpy.ndarray[numpy.float32[3, 3]]:
        ...
    @property
    def translation_vector(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
class Ray2D(Primitive2D):
    direction: numpy.ndarray[numpy.float64[2, 1]]
    origin: numpy.ndarray[numpy.float64[2, 1]]
    def __init__(self, id: int, origin: numpy.ndarray[numpy.float64[2, 1]], direction: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
class Rectangle2D(Primitive2D):
    center: numpy.ndarray[numpy.float64[2, 1]]
    orientation_angle: float
    def __init__(self, id: int, center: numpy.ndarray[numpy.float64[2, 1]], half_sizes: numpy.ndarray[numpy.float64[2, 1]], angle: float) -> None:
        ...
    def compute_points_on_boundary(self, num_points: int) -> list[numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    def translate(self, translation: numpy.ndarray[numpy.float64[2, 1]]) -> Rectangle2D:
        ...
    @property
    def half_sizes(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def rotation_matrix(self) -> numpy.ndarray[numpy.float64[2, 2]]:
        ...
class RgbdCamera3Dd(CameraBase3Dd):
    @staticmethod
    def Setting() -> CameraIntrinsicD:
        ...
    def __init__(self, setting: CameraIntrinsicD) -> None:
        ...
    def add_mesh(self, mesh_path: str) -> None:
        ...
    def scan(self, arg0: numpy.ndarray[numpy.float64[3, 3]], arg1: numpy.ndarray[numpy.float64[3, 1]]) -> dict:
        ...
    @property
    def ray_directions_in_frame(self) -> numpy.ndarray[numpy.float64]:
        ...
    @property
    def setting(self) -> CameraIntrinsicD:
        ...
class RgbdCamera3Df(CameraBase3Df):
    @staticmethod
    def Setting() -> CameraIntrinsicF:
        ...
    def __init__(self, setting: CameraIntrinsicF) -> None:
        ...
    def add_mesh(self, mesh_path: str) -> None:
        ...
    def scan(self, arg0: numpy.ndarray[numpy.float32[3, 3]], arg1: numpy.ndarray[numpy.float32[3, 1]]) -> dict:
        ...
    @property
    def ray_directions_in_frame(self) -> numpy.ndarray[numpy.float32]:
        ...
    @property
    def setting(self) -> CameraIntrinsicF:
        ...
class RgbdFrame3Dd(DepthFrame3Dd):
    def __init__(self, setting: DepthFrame3Dd.Setting) -> None:
        ...
    def convert_to_point_cloud(self, in_world_frame: bool) -> dict:
        ...
    def update_rgbd(self, rotation: numpy.ndarray[numpy.float64[3, 3], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float64[3, 1]], depth: numpy.ndarray[numpy.float64[m, n]], rgb: Mat) -> None:
        ...
class RgbdFrame3Df(DepthFrame3Df):
    def __init__(self, setting: DepthFrame3Df.Setting) -> None:
        ...
    def convert_to_point_cloud(self, in_world_frame: bool) -> dict:
        ...
    def update_rgbd(self, rotation: numpy.ndarray[numpy.float32[3, 3], numpy.ndarray.flags.f_contiguous], translation: numpy.ndarray[numpy.float32[3, 1]], depth: numpy.ndarray[numpy.float32[m, n]], rgb: Mat) -> None:
        ...
class Segment2D(Line2D):
    def __init__(self, id: int, p0: numpy.ndarray[numpy.float64[2, 1]], p1: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
class SemiSparseNdTreeSetting(NdTreeSetting):
    cache_voxel_centers: bool
    init_voxel_num: int
    semi_sparse_depth: int
    def __init__(self) -> None:
        ...
class SemiSparseOctreeD(AbstractOctreeD):
    class BottomLeafNeighborIterator(SemiSparseOctreeD.IteratorBase):
        pass
    class Drawer:
        @staticmethod
        def Setting() -> ...:
            ...
        def __init__(self, setting: ..., octree: SemiSparseOctreeD = None) -> None:
            ...
        @typing.overload
        def draw_leaves(self) -> list[...]:
            ...
        @typing.overload
        def draw_leaves(self, filename: str) -> None:
            ...
        @typing.overload
        def draw_tree(self) -> list[...]:
            ...
        @typing.overload
        def draw_tree(self, filename: str) -> None:
            ...
        def set_draw_leaf_callback(self, callback: typing.Callable[[SemiSparseOctreeD.Drawer, list[...], SemiSparseOctreeD.LeafInAabbIterator], None]) -> None:
            ...
        def set_draw_tree_callback(self, callback: typing.Callable[[SemiSparseOctreeD.Drawer, list[...], SemiSparseOctreeD.TreeInAabbIterator], None]) -> None:
            ...
        @property
        def setting(self) -> ...:
            ...
    class EastLeafNeighborIterator(SemiSparseOctreeD.IteratorBase):
        pass
    class IteratorBase(AbstractOctreeD.OctreeNodeIterator):
        __hash__: typing.ClassVar[None] = None
        def __eq__(self, arg0: SemiSparseOctreeD.IteratorBase) -> bool:
            ...
        def __ne__(self, arg0: SemiSparseOctreeD.IteratorBase) -> bool:
            ...
        @property
        def index_key(self) -> OctreeKey:
            ...
        @property
        def key(self) -> OctreeKey:
            ...
        @property
        def node(self) -> SemiSparseOctreeNode:
            ...
        @property
        def node_aabb(self) -> Aabb3Dd:
            ...
    class LeafInAabbIterator(SemiSparseOctreeD.IteratorBase):
        pass
    class LeafIterator(SemiSparseOctreeD.IteratorBase):
        pass
    class LeafOfNodeIterator(SemiSparseOctreeD.IteratorBase):
        pass
    class NodeOnRayIterator(SemiSparseOctreeD.IteratorBase):
        @property
        def distance(self) -> float:
            ...
    class NorthLeafNeighborIterator(SemiSparseOctreeD.IteratorBase):
        pass
    class SouthLeafNeighborIterator(SemiSparseOctreeD.IteratorBase):
        pass
    class TopLeafNeighborIterator(SemiSparseOctreeD.IteratorBase):
        pass
    class TreeInAabbIterator(SemiSparseOctreeD.IteratorBase):
        pass
    class TreeIterator(SemiSparseOctreeD.IteratorBase):
        pass
    class WestLeafNeighborIterator(SemiSparseOctreeD.IteratorBase):
        pass
    @staticmethod
    def Setting() -> SemiSparseNdTreeSetting:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, setting: SemiSparseNdTreeSetting) -> None:
        ...
    @typing.overload
    def __init__(self, filename: str) -> None:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: int, depth: int) -> int:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: OctreeKey, depth: int) -> OctreeKey:
        ...
    def clear(self) -> None:
        ...
    def compute_bottom_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_common_ancestor_key(self, arg0: OctreeKey, arg1: OctreeKey) -> tuple[OctreeKey, int]:
        ...
    def compute_east_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_north_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_ray_coords(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float) -> list[numpy.ndarray[numpy.float64[3, 1]]] | None:
        ...
    def compute_ray_keys(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float) -> list[OctreeKey] | None:
        ...
    def compute_south_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_top_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_west_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float) -> int:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float, depth: int) -> int:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, z: float) -> OctreeKey:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, z: float, depth: int) -> OctreeKey:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float, depth: int) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, z: float) -> OctreeKey | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, z: float, depth: int) -> OctreeKey | None:
        ...
    def create_node_child(self, node: SemiSparseOctreeNode, child_idx: int) -> SemiSparseOctreeNode:
        ...
    @typing.overload
    def delete_node(self, x: float, y: float, z: float, depth: int) -> int:
        ...
    @typing.overload
    def delete_node(self, key: OctreeKey, depth: int) -> None:
        ...
    def delete_node_child(self, node: SemiSparseOctreeNode, child_idx: int, key: OctreeKey) -> int:
        ...
    def expand(self) -> None:
        ...
    def expand_node(self, node: SemiSparseOctreeNode) -> None:
        ...
    def find_voxel_index(self, key: OctreeKey) -> int:
        ...
    @typing.overload
    def find_voxel_indices(self, points: numpy.ndarray[numpy.float64[3, n]], parallel: bool) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    @typing.overload
    def find_voxel_indices(self, keys: numpy.ndarray[numpy.uint32[3, n]], parallel: bool) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    def get_node_child(self, node: SemiSparseOctreeNode, child_idx: int) -> SemiSparseOctreeNode:
        ...
    def get_node_size(self, depth: int) -> float:
        ...
    def insert_key(self, key: OctreeKey, max_depth: int) -> int:
        ...
    @typing.overload
    def insert_keys(self, keys: numpy.ndarray[numpy.uint32[3, n]]) -> None:
        ...
    @typing.overload
    def insert_keys(self, keys: torch.Tensor) -> torch.Tensor:
        ...
    @typing.overload
    def insert_node(self, x: float, y: float, z: float, depth: int) -> SemiSparseOctreeNode:
        ...
    @typing.overload
    def insert_node(self, key: OctreeKey, depth: int) -> SemiSparseOctreeNode:
        ...
    @typing.overload
    def insert_points(self, points: numpy.ndarray[numpy.float64[3, n]]) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    @typing.overload
    def insert_points(self, points: torch.Tensor) -> torch.Tensor:
        ...
    def is_node_collapsible(self, node: SemiSparseOctreeNode) -> bool:
        ...
    @typing.overload
    def iter_bottom_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.BottomLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_bottom_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.BottomLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.EastLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.EastLeafNeighborIterator]:
        ...
    def iter_leaf(self, max_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.LeafIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_min_z: float, aabb_max_x: float, aabb_max_y: float, aabb_max_z: float, max_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.LeafInAabbIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_key: OctreeKey, aabb_max_key: OctreeKey, max_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.LeafInAabbIterator]:
        ...
    def iter_leaf_of_node(self, node_key: OctreeKey, node_depth: int, max_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.LeafOfNodeIterator]:
        ...
    def iter_node(self, max_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.TreeIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_min_z: float, aabb_max_x: float, aabb_max_y: float, aabb_max_z: float, max_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.TreeInAabbIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_key: OctreeKey, aabb_max_key: OctreeKey, max_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.TreeInAabbIterator]:
        ...
    def iter_node_on_ray(self, px: float, py: float, pz: float, vx: float, vy: float, vz: float, max_range: float = -1, node_padding: float = 0, bidirectional: bool = False, leaf_only: bool = True, min_node_depth: int = 0, max_node_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.NodeOnRayIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_top_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.TopLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_top_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.TopLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeD.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def key_to_coord(self, key: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: int, depth: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: OctreeKey) -> tuple[float, float, float]:
        ...
    @typing.overload
    def key_to_coord(self, key: OctreeKey, depth: int) -> tuple[float, float, float]:
        ...
    def prune(self) -> None:
        ...
    def prune_node(self, node: SemiSparseOctreeNode) -> bool:
        ...
    @typing.overload
    def search(self, x: float, y: float, z: float, max_depth: int = 0) -> SemiSparseOctreeNode:
        ...
    @typing.overload
    def search(self, key: OctreeKey, max_depth: int = 0) -> SemiSparseOctreeNode:
        ...
    def visualize(self, leaf_only: bool = False, scaling: float = 1.0, area_min: numpy.ndarray[numpy.float64[3, 1]] = ..., area_max: numpy.ndarray[numpy.float64[3, 1]] = ..., border_color: numpy.ndarray[numpy.float64[3, 1]] = ..., window_width: int = 1920, window_height: int = 1080, window_left: int = 50, window_top: int = 50) -> None:
        ...
    @property
    def children(self) -> numpy.ndarray[numpy.int64[8, n]]:
        ...
    @property
    def children_tensor(self) -> torch.Tensor:
        ...
    @property
    def memory_usage(self) -> int:
        ...
    @property
    def memory_usage_per_node(self) -> int:
        ...
    @property
    def metric_aabb(self) -> Aabb3Dd:
        ...
    @property
    def metric_max(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def metric_min(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def metric_min_max(self) -> tuple[numpy.ndarray[numpy.float64[3, 1]], numpy.ndarray[numpy.float64[3, 1]]]:
        ...
    @property
    def metric_size(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def num_vertices(self) -> int:
        ...
    @property
    def number_of_leaf_nodes(self) -> int:
        ...
    @property
    def number_of_nodes(self) -> int:
        ...
    @property
    def parents(self) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    @property
    def parents_tensor(self) -> torch.Tensor:
        ...
    @property
    def resolution(self) -> float:
        ...
    @property
    def root(self) -> SemiSparseOctreeNode:
        ...
    @property
    def setting(self) -> SemiSparseNdTreeSetting:
        ...
    @property
    def tree_center(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def tree_center_key(self) -> OctreeKey:
        ...
    @property
    def tree_depth(self) -> int:
        ...
    @property
    def tree_max_half_size(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def vertex_keys(self) -> list[OctreeKey]:
        ...
    @property
    def vertices(self) -> numpy.ndarray[numpy.int64[8, n]]:
        ...
    @property
    def vertices_tensor(self) -> torch.Tensor:
        ...
    @property
    def voxel_centers(self) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @property
    def voxel_centers_tensor(self) -> torch.Tensor:
        ...
    @property
    def voxels(self) -> numpy.ndarray[numpy.uint32[4, n]]:
        ...
    @property
    def voxels_tensor(self) -> torch.Tensor:
        ...
class SemiSparseOctreeF(AbstractOctreeF):
    class BottomLeafNeighborIterator(SemiSparseOctreeF.IteratorBase):
        pass
    class Drawer:
        @staticmethod
        def Setting() -> ...:
            ...
        def __init__(self, setting: ..., octree: SemiSparseOctreeF = None) -> None:
            ...
        @typing.overload
        def draw_leaves(self) -> list[...]:
            ...
        @typing.overload
        def draw_leaves(self, filename: str) -> None:
            ...
        @typing.overload
        def draw_tree(self) -> list[...]:
            ...
        @typing.overload
        def draw_tree(self, filename: str) -> None:
            ...
        def set_draw_leaf_callback(self, callback: typing.Callable[[SemiSparseOctreeF.Drawer, list[...], SemiSparseOctreeF.LeafInAabbIterator], None]) -> None:
            ...
        def set_draw_tree_callback(self, callback: typing.Callable[[SemiSparseOctreeF.Drawer, list[...], SemiSparseOctreeF.TreeInAabbIterator], None]) -> None:
            ...
        @property
        def setting(self) -> ...:
            ...
    class EastLeafNeighborIterator(SemiSparseOctreeF.IteratorBase):
        pass
    class IteratorBase(AbstractOctreeF.OctreeNodeIterator):
        __hash__: typing.ClassVar[None] = None
        def __eq__(self, arg0: SemiSparseOctreeF.IteratorBase) -> bool:
            ...
        def __ne__(self, arg0: SemiSparseOctreeF.IteratorBase) -> bool:
            ...
        @property
        def index_key(self) -> OctreeKey:
            ...
        @property
        def key(self) -> OctreeKey:
            ...
        @property
        def node(self) -> SemiSparseOctreeNode:
            ...
        @property
        def node_aabb(self) -> Aabb3Df:
            ...
    class LeafInAabbIterator(SemiSparseOctreeF.IteratorBase):
        pass
    class LeafIterator(SemiSparseOctreeF.IteratorBase):
        pass
    class LeafOfNodeIterator(SemiSparseOctreeF.IteratorBase):
        pass
    class NodeOnRayIterator(SemiSparseOctreeF.IteratorBase):
        @property
        def distance(self) -> float:
            ...
    class NorthLeafNeighborIterator(SemiSparseOctreeF.IteratorBase):
        pass
    class SouthLeafNeighborIterator(SemiSparseOctreeF.IteratorBase):
        pass
    class TopLeafNeighborIterator(SemiSparseOctreeF.IteratorBase):
        pass
    class TreeInAabbIterator(SemiSparseOctreeF.IteratorBase):
        pass
    class TreeIterator(SemiSparseOctreeF.IteratorBase):
        pass
    class WestLeafNeighborIterator(SemiSparseOctreeF.IteratorBase):
        pass
    @staticmethod
    def Setting() -> SemiSparseNdTreeSetting:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, setting: SemiSparseNdTreeSetting) -> None:
        ...
    @typing.overload
    def __init__(self, filename: str) -> None:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: int, depth: int) -> int:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: OctreeKey, depth: int) -> OctreeKey:
        ...
    def clear(self) -> None:
        ...
    def compute_bottom_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_common_ancestor_key(self, arg0: OctreeKey, arg1: OctreeKey) -> tuple[OctreeKey, int]:
        ...
    def compute_east_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_north_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_ray_coords(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float) -> list[numpy.ndarray[numpy.float32[3, 1]]] | None:
        ...
    def compute_ray_keys(self, sx: float, sy: float, sz: float, ex: float, ey: float, ez: float) -> list[OctreeKey] | None:
        ...
    def compute_south_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_top_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    def compute_west_neighbor_key(self, key: OctreeKey, depth: int) -> OctreeKey | None:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float) -> int:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float, depth: int) -> int:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, z: float) -> OctreeKey:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, z: float, depth: int) -> OctreeKey:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float, depth: int) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, z: float) -> OctreeKey | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, z: float, depth: int) -> OctreeKey | None:
        ...
    def create_node_child(self, node: SemiSparseOctreeNode, child_idx: int) -> SemiSparseOctreeNode:
        ...
    @typing.overload
    def delete_node(self, x: float, y: float, z: float, depth: int) -> int:
        ...
    @typing.overload
    def delete_node(self, key: OctreeKey, depth: int) -> None:
        ...
    def delete_node_child(self, node: SemiSparseOctreeNode, child_idx: int, key: OctreeKey) -> int:
        ...
    def expand(self) -> None:
        ...
    def expand_node(self, node: SemiSparseOctreeNode) -> None:
        ...
    def find_voxel_index(self, key: OctreeKey) -> int:
        ...
    @typing.overload
    def find_voxel_indices(self, points: numpy.ndarray[numpy.float32[3, n]], parallel: bool) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    @typing.overload
    def find_voxel_indices(self, keys: numpy.ndarray[numpy.uint32[3, n]], parallel: bool) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    def get_node_child(self, node: SemiSparseOctreeNode, child_idx: int) -> SemiSparseOctreeNode:
        ...
    def get_node_size(self, depth: int) -> float:
        ...
    def insert_key(self, key: OctreeKey, max_depth: int) -> int:
        ...
    @typing.overload
    def insert_keys(self, keys: numpy.ndarray[numpy.uint32[3, n]]) -> None:
        ...
    @typing.overload
    def insert_keys(self, keys: torch.Tensor) -> torch.Tensor:
        ...
    @typing.overload
    def insert_node(self, x: float, y: float, z: float, depth: int) -> SemiSparseOctreeNode:
        ...
    @typing.overload
    def insert_node(self, key: OctreeKey, depth: int) -> SemiSparseOctreeNode:
        ...
    @typing.overload
    def insert_points(self, points: numpy.ndarray[numpy.float32[3, n]]) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    @typing.overload
    def insert_points(self, points: torch.Tensor) -> torch.Tensor:
        ...
    def is_node_collapsible(self, node: SemiSparseOctreeNode) -> bool:
        ...
    @typing.overload
    def iter_bottom_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.BottomLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_bottom_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.BottomLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.EastLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.EastLeafNeighborIterator]:
        ...
    def iter_leaf(self, max_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.LeafIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_min_z: float, aabb_max_x: float, aabb_max_y: float, aabb_max_z: float, max_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.LeafInAabbIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_key: OctreeKey, aabb_max_key: OctreeKey, max_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.LeafInAabbIterator]:
        ...
    def iter_leaf_of_node(self, node_key: OctreeKey, node_depth: int, max_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.LeafOfNodeIterator]:
        ...
    def iter_node(self, max_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.TreeIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_min_z: float, aabb_max_x: float, aabb_max_y: float, aabb_max_z: float, max_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.TreeInAabbIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_key: OctreeKey, aabb_max_key: OctreeKey, max_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.TreeInAabbIterator]:
        ...
    def iter_node_on_ray(self, px: float, py: float, pz: float, vx: float, vy: float, vz: float, max_range: float = -1, node_padding: float = 0, bidirectional: bool = False, leaf_only: bool = True, min_node_depth: int = 0, max_node_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.NodeOnRayIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_top_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.TopLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_top_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.TopLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, x: float, y: float, z: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, key: OctreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseOctreeF.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def key_to_coord(self, key: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: int, depth: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: OctreeKey) -> tuple[float, float, float]:
        ...
    @typing.overload
    def key_to_coord(self, key: OctreeKey, depth: int) -> tuple[float, float, float]:
        ...
    def prune(self) -> None:
        ...
    def prune_node(self, node: SemiSparseOctreeNode) -> bool:
        ...
    @typing.overload
    def search(self, x: float, y: float, z: float, max_depth: int = 0) -> SemiSparseOctreeNode:
        ...
    @typing.overload
    def search(self, key: OctreeKey, max_depth: int = 0) -> SemiSparseOctreeNode:
        ...
    def visualize(self, leaf_only: bool = False, scaling: float = 1.0, area_min: numpy.ndarray[numpy.float64[3, 1]] = ..., area_max: numpy.ndarray[numpy.float64[3, 1]] = ..., border_color: numpy.ndarray[numpy.float64[3, 1]] = ..., window_width: int = 1920, window_height: int = 1080, window_left: int = 50, window_top: int = 50) -> None:
        ...
    @property
    def children(self) -> numpy.ndarray[numpy.int64[8, n]]:
        ...
    @property
    def children_tensor(self) -> torch.Tensor:
        ...
    @property
    def memory_usage(self) -> int:
        ...
    @property
    def memory_usage_per_node(self) -> int:
        ...
    @property
    def metric_aabb(self) -> Aabb3Df:
        ...
    @property
    def metric_max(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def metric_min(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def metric_min_max(self) -> tuple[numpy.ndarray[numpy.float32[3, 1]], numpy.ndarray[numpy.float32[3, 1]]]:
        ...
    @property
    def metric_size(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def num_vertices(self) -> int:
        ...
    @property
    def number_of_leaf_nodes(self) -> int:
        ...
    @property
    def number_of_nodes(self) -> int:
        ...
    @property
    def parents(self) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    @property
    def parents_tensor(self) -> torch.Tensor:
        ...
    @property
    def resolution(self) -> float:
        ...
    @property
    def root(self) -> SemiSparseOctreeNode:
        ...
    @property
    def setting(self) -> SemiSparseNdTreeSetting:
        ...
    @property
    def tree_center(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def tree_center_key(self) -> OctreeKey:
        ...
    @property
    def tree_depth(self) -> int:
        ...
    @property
    def tree_max_half_size(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    @property
    def vertex_keys(self) -> list[OctreeKey]:
        ...
    @property
    def vertices(self) -> numpy.ndarray[numpy.int64[8, n]]:
        ...
    @property
    def vertices_tensor(self) -> torch.Tensor:
        ...
    @property
    def voxel_centers(self) -> numpy.ndarray[numpy.float32[3, n]]:
        ...
    @property
    def voxel_centers_tensor(self) -> torch.Tensor:
        ...
    @property
    def voxels(self) -> numpy.ndarray[numpy.uint32[4, n]]:
        ...
    @property
    def voxels_tensor(self) -> torch.Tensor:
        ...
class SemiSparseOctreeNode(AbstractOctreeNode):
    @property
    def node_index(self) -> int:
        ...
class SemiSparseQuadtreeD(AbstractQuadtreeD):
    class Drawer:
        @staticmethod
        def Setting() -> ...:
            ...
        def __init__(self, setting: ..., quadtree: SemiSparseQuadtreeD = None) -> None:
            ...
        @typing.overload
        def draw_leaves(self) -> Mat:
            ...
        @typing.overload
        def draw_leaves(self, filename: str) -> None:
            ...
        @typing.overload
        def draw_tree(self) -> Mat:
            ...
        @typing.overload
        def draw_tree(self, filename: str) -> None:
            ...
        def set_draw_leaf_callback(self, callback: typing.Callable[[SemiSparseQuadtreeD.Drawer, Mat, SemiSparseQuadtreeD.LeafInAabbIterator], None]) -> None:
            ...
        def set_draw_tree_callback(self, callback: typing.Callable[[SemiSparseQuadtreeD.Drawer, Mat, SemiSparseQuadtreeD.TreeInAabbIterator], None]) -> None:
            ...
        @property
        def grid_map_info(self) -> ...:
            ...
        @property
        def setting(self) -> ...:
            ...
    class EastLeafNeighborIterator(SemiSparseQuadtreeD.IteratorBase):
        pass
    class IteratorBase(AbstractQuadtreeD.QuadtreeNodeIterator):
        __hash__: typing.ClassVar[None] = None
        def __eq__(self, arg0: SemiSparseQuadtreeD.IteratorBase) -> bool:
            ...
        def __ne__(self, arg0: SemiSparseQuadtreeD.IteratorBase) -> bool:
            ...
        @property
        def index_key(self) -> QuadtreeKey:
            ...
        @property
        def key(self) -> QuadtreeKey:
            ...
        @property
        def node(self) -> SemiSparseQuadtreeNode:
            ...
        @property
        def node_aabb(self) -> Aabb2Dd:
            ...
    class LeafInAabbIterator(SemiSparseQuadtreeD.IteratorBase):
        pass
    class LeafIterator(SemiSparseQuadtreeD.IteratorBase):
        pass
    class LeafOfNodeIterator(SemiSparseQuadtreeD.IteratorBase):
        pass
    class NodeOnRayIterator(SemiSparseQuadtreeD.IteratorBase):
        @property
        def distance(self) -> float:
            ...
    class NorthLeafNeighborIterator(SemiSparseQuadtreeD.IteratorBase):
        pass
    class SouthLeafNeighborIterator(SemiSparseQuadtreeD.IteratorBase):
        pass
    class TreeInAabbIterator(SemiSparseQuadtreeD.IteratorBase):
        pass
    class TreeIterator(SemiSparseQuadtreeD.IteratorBase):
        pass
    class WestLeafNeighborIterator(SemiSparseQuadtreeD.IteratorBase):
        pass
    @staticmethod
    def Setting() -> SemiSparseNdTreeSetting:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, setting: SemiSparseNdTreeSetting) -> None:
        ...
    @typing.overload
    def __init__(self, filename: str) -> None:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: int, depth: int) -> int:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: QuadtreeKey, depth: int) -> QuadtreeKey:
        ...
    def clear(self) -> None:
        ...
    def compute_common_ancestor_key(self, arg0: QuadtreeKey, arg1: QuadtreeKey) -> tuple[QuadtreeKey, int]:
        ...
    def compute_east_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_north_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_ray_coords(self, sx: float, sy: float, ex: float, ey: float) -> list[numpy.ndarray[numpy.float64[2, 1]]] | None:
        ...
    def compute_ray_keys(self, sx: float, sy: float, ex: float, ey: float) -> list[QuadtreeKey] | None:
        ...
    def compute_south_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_west_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float) -> int:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float, depth: int) -> int:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float) -> QuadtreeKey:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, depth: int) -> QuadtreeKey:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float, depth: int) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float) -> QuadtreeKey | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, depth: int) -> QuadtreeKey | None:
        ...
    def create_node_child(self, node: SemiSparseQuadtreeNode, child_idx: int) -> SemiSparseQuadtreeNode:
        ...
    @typing.overload
    def delete_node(self, x: float, y: float, depth: int) -> int:
        ...
    @typing.overload
    def delete_node(self, key: QuadtreeKey, depth: int) -> None:
        ...
    def delete_node_child(self, node: SemiSparseQuadtreeNode, child_idx: int, key: QuadtreeKey) -> int:
        ...
    def expand(self) -> None:
        ...
    def expand_node(self, node: SemiSparseQuadtreeNode) -> None:
        ...
    def find_voxel_index(self, key: QuadtreeKey) -> int:
        ...
    @typing.overload
    def find_voxel_indices(self, points: numpy.ndarray[numpy.float64[2, n]], parallel: bool) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    @typing.overload
    def find_voxel_indices(self, keys: numpy.ndarray[numpy.uint32[2, n]], parallel: bool) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    def get_node_child(self, node: SemiSparseQuadtreeNode, child_idx: int) -> SemiSparseQuadtreeNode:
        ...
    def get_node_size(self, depth: int) -> float:
        ...
    def insert_key(self, key: QuadtreeKey, max_depth: int) -> int:
        ...
    @typing.overload
    def insert_keys(self, keys: numpy.ndarray[numpy.uint32[2, n]]) -> None:
        ...
    @typing.overload
    def insert_keys(self, keys: torch.Tensor) -> torch.Tensor:
        ...
    @typing.overload
    def insert_node(self, x: float, y: float, depth: int) -> SemiSparseQuadtreeNode:
        ...
    @typing.overload
    def insert_node(self, key: QuadtreeKey, depth: int) -> SemiSparseQuadtreeNode:
        ...
    @typing.overload
    def insert_points(self, points: numpy.ndarray[numpy.float64[2, n]]) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    @typing.overload
    def insert_points(self, points: torch.Tensor) -> torch.Tensor:
        ...
    def is_node_collapsible(self, node: SemiSparseQuadtreeNode) -> bool:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.EastLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.EastLeafNeighborIterator]:
        ...
    def iter_leaf(self, max_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.LeafIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_max_x: float, aabb_max_y: float, max_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.LeafInAabbIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_key: QuadtreeKey, aabb_max_key: QuadtreeKey, max_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.LeafInAabbIterator]:
        ...
    def iter_leaf_of_node(self, node_key: QuadtreeKey, node_depth: int, max_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.LeafOfNodeIterator]:
        ...
    def iter_node(self, max_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.TreeIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_max_x: float, aabb_max_y: float, max_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.TreeInAabbIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_key: QuadtreeKey, aabb_max_key: QuadtreeKey, max_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.TreeInAabbIterator]:
        ...
    def iter_node_on_ray(self, px: float, py: float, vx: float, vy: float, max_range: float = -1, node_padding: float = 0, bidirectional: bool = False, leaf_only: bool = False, min_node_depth: int = 0, max_node_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.NodeOnRayIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeD.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def key_to_coord(self, key: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: int, depth: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: QuadtreeKey) -> tuple[float, float]:
        ...
    @typing.overload
    def key_to_coord(self, key: QuadtreeKey, depth: int) -> tuple[float, float]:
        ...
    def prune(self) -> None:
        ...
    def prune_node(self, node: SemiSparseQuadtreeNode) -> bool:
        ...
    @typing.overload
    def search(self, x: float, y: float, max_depth: int = 0) -> SemiSparseQuadtreeNode:
        ...
    @typing.overload
    def search(self, key: QuadtreeKey, max_depth: int = 0) -> SemiSparseQuadtreeNode:
        ...
    def visualize(self, leaf_only: bool = False, area_min: numpy.ndarray[numpy.float32[2, 1]] | None = None, area_max: numpy.ndarray[numpy.float32[2, 1]] | None = None, resolution: float = 0.1, padding: int = 1, bg_color: numpy.ndarray[numpy.int32[4, 1]] = ..., fg_color: numpy.ndarray[numpy.int32[4, 1]] = ..., border_color: numpy.ndarray[numpy.int32[4, 1]] = ..., border_thickness: int = 1) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def children(self) -> numpy.ndarray[numpy.int64[4, n]]:
        ...
    @property
    def children_tensor(self) -> torch.Tensor:
        ...
    @property
    def memory_usage(self) -> int:
        ...
    @property
    def memory_usage_per_node(self) -> int:
        ...
    @property
    def metric_aabb(self) -> Aabb2Dd:
        ...
    @property
    def metric_max(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def metric_min(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def metric_min_max(self) -> tuple[numpy.ndarray[numpy.float64[2, 1]], numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    @property
    def metric_size(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def num_vertices(self) -> int:
        ...
    @property
    def number_of_leaf_nodes(self) -> int:
        ...
    @property
    def number_of_nodes(self) -> int:
        ...
    @property
    def parents(self) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    @property
    def parents_tensor(self) -> torch.Tensor:
        ...
    @property
    def resolution(self) -> float:
        ...
    @property
    def root(self) -> SemiSparseQuadtreeNode:
        ...
    @property
    def setting(self) -> SemiSparseNdTreeSetting:
        ...
    @property
    def tree_center(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def tree_center_key(self) -> QuadtreeKey:
        ...
    @property
    def tree_depth(self) -> int:
        ...
    @property
    def tree_max_half_size(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @property
    def vertex_keys(self) -> list[QuadtreeKey]:
        ...
    @property
    def vertices(self) -> numpy.ndarray[numpy.int64[4, n]]:
        ...
    @property
    def vertices_tensor(self) -> torch.Tensor:
        ...
    @property
    def voxel_centers(self) -> numpy.ndarray[numpy.float64[2, n]]:
        ...
    @property
    def voxel_centers_tensor(self) -> torch.Tensor:
        ...
    @property
    def voxels(self) -> numpy.ndarray[numpy.uint32[3, n]]:
        ...
    @property
    def voxels_tensor(self) -> torch.Tensor:
        ...
class SemiSparseQuadtreeF(AbstractQuadtreeF):
    class Drawer:
        @staticmethod
        def Setting() -> ...:
            ...
        def __init__(self, setting: ..., quadtree: SemiSparseQuadtreeF = None) -> None:
            ...
        @typing.overload
        def draw_leaves(self) -> Mat:
            ...
        @typing.overload
        def draw_leaves(self, filename: str) -> None:
            ...
        @typing.overload
        def draw_tree(self) -> Mat:
            ...
        @typing.overload
        def draw_tree(self, filename: str) -> None:
            ...
        def set_draw_leaf_callback(self, callback: typing.Callable[[SemiSparseQuadtreeF.Drawer, Mat, SemiSparseQuadtreeF.LeafInAabbIterator], None]) -> None:
            ...
        def set_draw_tree_callback(self, callback: typing.Callable[[SemiSparseQuadtreeF.Drawer, Mat, SemiSparseQuadtreeF.TreeInAabbIterator], None]) -> None:
            ...
        @property
        def grid_map_info(self) -> ...:
            ...
        @property
        def setting(self) -> ...:
            ...
    class EastLeafNeighborIterator(SemiSparseQuadtreeF.IteratorBase):
        pass
    class IteratorBase(AbstractQuadtreeF.QuadtreeNodeIterator):
        __hash__: typing.ClassVar[None] = None
        def __eq__(self, arg0: SemiSparseQuadtreeF.IteratorBase) -> bool:
            ...
        def __ne__(self, arg0: SemiSparseQuadtreeF.IteratorBase) -> bool:
            ...
        @property
        def index_key(self) -> QuadtreeKey:
            ...
        @property
        def key(self) -> QuadtreeKey:
            ...
        @property
        def node(self) -> SemiSparseQuadtreeNode:
            ...
        @property
        def node_aabb(self) -> Aabb2Df:
            ...
    class LeafInAabbIterator(SemiSparseQuadtreeF.IteratorBase):
        pass
    class LeafIterator(SemiSparseQuadtreeF.IteratorBase):
        pass
    class LeafOfNodeIterator(SemiSparseQuadtreeF.IteratorBase):
        pass
    class NodeOnRayIterator(SemiSparseQuadtreeF.IteratorBase):
        @property
        def distance(self) -> float:
            ...
    class NorthLeafNeighborIterator(SemiSparseQuadtreeF.IteratorBase):
        pass
    class SouthLeafNeighborIterator(SemiSparseQuadtreeF.IteratorBase):
        pass
    class TreeInAabbIterator(SemiSparseQuadtreeF.IteratorBase):
        pass
    class TreeIterator(SemiSparseQuadtreeF.IteratorBase):
        pass
    class WestLeafNeighborIterator(SemiSparseQuadtreeF.IteratorBase):
        pass
    @staticmethod
    def Setting() -> SemiSparseNdTreeSetting:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, setting: SemiSparseNdTreeSetting) -> None:
        ...
    @typing.overload
    def __init__(self, filename: str) -> None:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: int, depth: int) -> int:
        ...
    @typing.overload
    def adjust_key_to_depth(self, key: QuadtreeKey, depth: int) -> QuadtreeKey:
        ...
    def clear(self) -> None:
        ...
    def compute_common_ancestor_key(self, arg0: QuadtreeKey, arg1: QuadtreeKey) -> tuple[QuadtreeKey, int]:
        ...
    def compute_east_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_north_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_ray_coords(self, sx: float, sy: float, ex: float, ey: float) -> list[numpy.ndarray[numpy.float32[2, 1]]] | None:
        ...
    def compute_ray_keys(self, sx: float, sy: float, ex: float, ey: float) -> list[QuadtreeKey] | None:
        ...
    def compute_south_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    def compute_west_neighbor_key(self, key: QuadtreeKey, depth: int) -> QuadtreeKey | None:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float) -> int:
        ...
    @typing.overload
    def coord_to_key(self, coordinate: float, depth: int) -> int:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float) -> QuadtreeKey:
        ...
    @typing.overload
    def coord_to_key(self, x: float, y: float, depth: int) -> QuadtreeKey:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, coordinate: float, depth: int) -> int | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float) -> QuadtreeKey | None:
        ...
    @typing.overload
    def coord_to_key_checked(self, x: float, y: float, depth: int) -> QuadtreeKey | None:
        ...
    def create_node_child(self, node: SemiSparseQuadtreeNode, child_idx: int) -> SemiSparseQuadtreeNode:
        ...
    @typing.overload
    def delete_node(self, x: float, y: float, depth: int) -> int:
        ...
    @typing.overload
    def delete_node(self, key: QuadtreeKey, depth: int) -> None:
        ...
    def delete_node_child(self, node: SemiSparseQuadtreeNode, child_idx: int, key: QuadtreeKey) -> int:
        ...
    def expand(self) -> None:
        ...
    def expand_node(self, node: SemiSparseQuadtreeNode) -> None:
        ...
    def find_voxel_index(self, key: QuadtreeKey) -> int:
        ...
    @typing.overload
    def find_voxel_indices(self, points: numpy.ndarray[numpy.float32[2, n]], parallel: bool) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    @typing.overload
    def find_voxel_indices(self, keys: numpy.ndarray[numpy.uint32[2, n]], parallel: bool) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    def get_node_child(self, node: SemiSparseQuadtreeNode, child_idx: int) -> SemiSparseQuadtreeNode:
        ...
    def get_node_size(self, depth: int) -> float:
        ...
    def insert_key(self, key: QuadtreeKey, max_depth: int) -> int:
        ...
    @typing.overload
    def insert_keys(self, keys: numpy.ndarray[numpy.uint32[2, n]]) -> None:
        ...
    @typing.overload
    def insert_keys(self, keys: torch.Tensor) -> torch.Tensor:
        ...
    @typing.overload
    def insert_node(self, x: float, y: float, depth: int) -> SemiSparseQuadtreeNode:
        ...
    @typing.overload
    def insert_node(self, key: QuadtreeKey, depth: int) -> SemiSparseQuadtreeNode:
        ...
    @typing.overload
    def insert_points(self, points: numpy.ndarray[numpy.float32[2, n]]) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    @typing.overload
    def insert_points(self, points: torch.Tensor) -> torch.Tensor:
        ...
    def is_node_collapsible(self, node: SemiSparseQuadtreeNode) -> bool:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.EastLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_east_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.EastLeafNeighborIterator]:
        ...
    def iter_leaf(self, max_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.LeafIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_max_x: float, aabb_max_y: float, max_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.LeafInAabbIterator]:
        ...
    @typing.overload
    def iter_leaf_in_aabb(self, aabb_min_key: QuadtreeKey, aabb_max_key: QuadtreeKey, max_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.LeafInAabbIterator]:
        ...
    def iter_leaf_of_node(self, node_key: QuadtreeKey, node_depth: int, max_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.LeafOfNodeIterator]:
        ...
    def iter_node(self, max_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.TreeIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_x: float, aabb_min_y: float, aabb_max_x: float, aabb_max_y: float, max_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.TreeInAabbIterator]:
        ...
    @typing.overload
    def iter_node_in_aabb(self, aabb_min_key: QuadtreeKey, aabb_max_key: QuadtreeKey, max_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.TreeInAabbIterator]:
        ...
    def iter_node_on_ray(self, px: float, py: float, vx: float, vy: float, max_range: float = -1, node_padding: float = 0, bidirectional: bool = False, leaf_only: bool = False, min_node_depth: int = 0, max_node_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.NodeOnRayIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_north_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.NorthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_south_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.SouthLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, x: float, y: float, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def iter_west_leaf_neighbor(self, key: QuadtreeKey, key_depth: int, max_leaf_depth: int = 0) -> typing.Iterator[SemiSparseQuadtreeF.WestLeafNeighborIterator]:
        ...
    @typing.overload
    def key_to_coord(self, key: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: int, depth: int) -> float:
        ...
    @typing.overload
    def key_to_coord(self, key: QuadtreeKey) -> tuple[float, float]:
        ...
    @typing.overload
    def key_to_coord(self, key: QuadtreeKey, depth: int) -> tuple[float, float]:
        ...
    def prune(self) -> None:
        ...
    def prune_node(self, node: SemiSparseQuadtreeNode) -> bool:
        ...
    @typing.overload
    def search(self, x: float, y: float, max_depth: int = 0) -> SemiSparseQuadtreeNode:
        ...
    @typing.overload
    def search(self, key: QuadtreeKey, max_depth: int = 0) -> SemiSparseQuadtreeNode:
        ...
    def visualize(self, leaf_only: bool = False, area_min: numpy.ndarray[numpy.float32[2, 1]] | None = None, area_max: numpy.ndarray[numpy.float32[2, 1]] | None = None, resolution: float = 0.1, padding: int = 1, bg_color: numpy.ndarray[numpy.int32[4, 1]] = ..., fg_color: numpy.ndarray[numpy.int32[4, 1]] = ..., border_color: numpy.ndarray[numpy.int32[4, 1]] = ..., border_thickness: int = 1) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @property
    def children(self) -> numpy.ndarray[numpy.int64[4, n]]:
        ...
    @property
    def children_tensor(self) -> torch.Tensor:
        ...
    @property
    def memory_usage(self) -> int:
        ...
    @property
    def memory_usage_per_node(self) -> int:
        ...
    @property
    def metric_aabb(self) -> Aabb2Df:
        ...
    @property
    def metric_max(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def metric_min(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def metric_min_max(self) -> tuple[numpy.ndarray[numpy.float32[2, 1]], numpy.ndarray[numpy.float32[2, 1]]]:
        ...
    @property
    def metric_size(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def num_vertices(self) -> int:
        ...
    @property
    def number_of_leaf_nodes(self) -> int:
        ...
    @property
    def number_of_nodes(self) -> int:
        ...
    @property
    def parents(self) -> numpy.ndarray[numpy.int64[m, 1]]:
        ...
    @property
    def parents_tensor(self) -> torch.Tensor:
        ...
    @property
    def resolution(self) -> float:
        ...
    @property
    def root(self) -> SemiSparseQuadtreeNode:
        ...
    @property
    def setting(self) -> SemiSparseNdTreeSetting:
        ...
    @property
    def tree_center(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def tree_center_key(self) -> QuadtreeKey:
        ...
    @property
    def tree_depth(self) -> int:
        ...
    @property
    def tree_max_half_size(self) -> numpy.ndarray[numpy.float32[2, 1]]:
        ...
    @property
    def vertex_keys(self) -> list[QuadtreeKey]:
        ...
    @property
    def vertices(self) -> numpy.ndarray[numpy.int64[4, n]]:
        ...
    @property
    def vertices_tensor(self) -> torch.Tensor:
        ...
    @property
    def voxel_centers(self) -> numpy.ndarray[numpy.float32[2, n]]:
        ...
    @property
    def voxel_centers_tensor(self) -> torch.Tensor:
        ...
    @property
    def voxels(self) -> numpy.ndarray[numpy.uint32[3, n]]:
        ...
    @property
    def voxels_tensor(self) -> torch.Tensor:
        ...
class SemiSparseQuadtreeNode(AbstractQuadtreeNode):
    @property
    def node_index(self) -> int:
        ...
class Space2D:
    class SignMethod:
        """
        Algorithm to determine SDF sign.
        
        Members:
        
          kPointNormal : Use the normal of the nearest vertex to determine the sign.
        
          kLineNormal : Use the normal of the nearest line segment to determine the sign.
        
          kPolygon : Use the nearest object polygon and the winding number algorithm to determine the sign.
        """
        __members__: typing.ClassVar[dict[str, Space2D.SignMethod]]  # value = {'kPointNormal': <SignMethod.kPointNormal: 0>, 'kLineNormal': <SignMethod.kLineNormal: 1>, 'kPolygon': <SignMethod.kPolygon: 2>}
        kLineNormal: typing.ClassVar[Space2D.SignMethod]  # value = <SignMethod.kLineNormal: 1>
        kPointNormal: typing.ClassVar[Space2D.SignMethod]  # value = <SignMethod.kPointNormal: 0>
        kPolygon: typing.ClassVar[Space2D.SignMethod]  # value = <SignMethod.kPolygon: 2>
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __ge__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __gt__(self, other: typing.Any) -> bool:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __le__(self, other: typing.Any) -> bool:
            ...
        def __lt__(self, other: typing.Any) -> bool:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    kLineNormal: typing.ClassVar[Space2D.SignMethod]  # value = <SignMethod.kLineNormal: 1>
    kPointNormal: typing.ClassVar[Space2D.SignMethod]  # value = <SignMethod.kPointNormal: 0>
    kPolygon: typing.ClassVar[Space2D.SignMethod]  # value = <SignMethod.kPolygon: 2>
    @staticmethod
    @typing.overload
    def __init__(*args, **kwargs) -> None:
        ...
    @staticmethod
    @typing.overload
    def compute_ddf(*args, **kwargs) -> numpy.ndarray[numpy.float64]:
        ...
    @staticmethod
    @typing.overload
    def compute_sddf_v1(*args, **kwargs) -> numpy.ndarray[numpy.float64]:
        ...
    @staticmethod
    @typing.overload
    def compute_sddf_v2(*args, **kwargs) -> numpy.ndarray[numpy.float64]:
        ...
    @staticmethod
    def compute_sdf_image(*args, **kwargs) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @staticmethod
    def generate_map_image(*args, **kwargs) -> numpy.ndarray[numpy.uint8[m, n]]:
        ...
    @staticmethod
    def get_sign_method_from_name(sign_method_name: str) -> Space2D.SignMethod:
        ...
    @staticmethod
    def get_sign_method_name(sign_method: Space2D.SignMethod) -> str:
        ...
    @typing.overload
    def __init__(self, ordered_object_vertices: list[numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous]], ordered_object_normals: list[numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous]]) -> None:
        ...
    @typing.overload
    def __init__(self, ordered_object_vertices: list[numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous]], outside_flags: numpy.ndarray[bool[m, 1]], delta: float = 0.01, parallel: bool = False) -> None:
        ...
    @typing.overload
    def __init__(self, space2d: Space2D) -> None:
        ...
    @typing.overload
    def compute_ddf(self, query_points: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous], query_directions: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous], parallel: bool = False) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def compute_sddf_v1(self, query_points: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous], query_directions: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous], parallel: bool = False) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def compute_sddf_v2(self, query_points: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous], query_directions: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous], sign_method: Space2D.SignMethod = ..., parallel: bool = False) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def compute_sdf(self, query_points: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous], sign_method: Space2D.SignMethod = ..., use_kd_tree: bool = False, parallel: bool = False) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def compute_sdf_greedily(self, q: numpy.ndarray[numpy.float64[2, 1]], sign_method: Space2D.SignMethod) -> float:
        ...
    def compute_sdf_with_kdtree(self, q: numpy.ndarray[numpy.float64[2, 1]], sign_method: Space2D.SignMethod) -> float:
        ...
    @property
    def surface(self) -> Surface2D:
        ...
class Surface2D:
    lines_to_vertices: numpy.ndarray[numpy.int32[2, n]]
    normals: numpy.ndarray[numpy.float64[2, n]]
    objects_to_lines: numpy.ndarray[numpy.int32[2, n]]
    outside_flags: numpy.ndarray[bool[m, 1]]
    vertices: numpy.ndarray[numpy.float64[2, n]]
    vertices_to_objects: numpy.ndarray[numpy.int32[m, 1]]
    @typing.overload
    def __init__(self, vertices: numpy.ndarray[numpy.float64[2, n]], normals: numpy.ndarray[numpy.float64[2, n]], lines2vertices: numpy.ndarray[numpy.int32[2, n]], objects2lines: numpy.ndarray[numpy.int32[2, n]], outside_flags: numpy.ndarray[bool[m, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, surface: Surface2D) -> None:
        ...
    def get_object_normals(self, index_object: int) -> numpy.ndarray[numpy.float64[2, n]]:
        ...
    def get_object_vertices(self, index_object: int) -> numpy.ndarray[numpy.float64[2, n]]:
        ...
    def get_vertex_neighbors(self, index_vertex: int) -> tuple[int, int]:
        ...
    @property
    def normals_available(self) -> bool:
        ...
    @property
    def num_lines(self) -> int:
        ...
    @property
    def num_objects(self) -> int:
        ...
    @property
    def num_vertices(self) -> int:
        ...
    @property
    def outside_flags_available(self) -> bool:
        ...
class TrajectoryD:
    @staticmethod
    def load_2d(filename: str, binary: bool) -> list[numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    @staticmethod
    def load_3d(filename: str, binary: bool) -> list[numpy.ndarray[numpy.float64[3, 1]]]:
        ...
    @staticmethod
    def load_se2(filename: str, binary: bool) -> list[tuple[numpy.ndarray[numpy.float64[2, 2]], numpy.ndarray[numpy.float64[2, 1]]]]:
        ...
    @staticmethod
    def load_se3(filename: str, binary: bool) -> list[tuple[numpy.ndarray[numpy.float64[3, 3]], numpy.ndarray[numpy.float64[3, 1]]]]:
        ...
    def __init__(self) -> None:
        ...
class TrajectoryF:
    @staticmethod
    def load_2d(filename: str, binary: bool) -> list[numpy.ndarray[numpy.float32[2, 1]]]:
        ...
    @staticmethod
    def load_3d(filename: str, binary: bool) -> list[numpy.ndarray[numpy.float32[3, 1]]]:
        ...
    @staticmethod
    def load_se2(filename: str, binary: bool) -> list[tuple[numpy.ndarray[numpy.float32[2, 2]], numpy.ndarray[numpy.float32[2, 1]]]]:
        ...
    @staticmethod
    def load_se3(filename: str, binary: bool) -> list[tuple[numpy.ndarray[numpy.float32[3, 3]], numpy.ndarray[numpy.float32[3, 1]]]]:
        ...
    def __init__(self) -> None:
        ...
class YamlableBase:
    def __str__(self) -> str:
        ...
    def as_yaml_file(self, yaml_file: str) -> None:
        ...
    def as_yaml_string(self) -> str:
        ...
    def from_yaml_file(self, yaml_file: str) -> bool:
        ...
    def from_yaml_string(self, yaml_str: str) -> bool:
        ...
def bresenham_2d(start: numpy.ndarray[numpy.int32[2, 1]], end: numpy.ndarray[numpy.int32[2, 1]], stop: typing.Callable[[int, int], bool] | None = None) -> numpy.ndarray[numpy.int32[2, n]]:
    ...
def compute_intersection_between_line_and_ellipse_2d(x0: float, y0: float, x1: float, y1: float, a: float, b: float) -> tuple:
    ...
def compute_intersection_between_line_and_ellipsoid_3d(x0: float, y0: float, z0: float, x1: float, y1: float, z1: float, a: float, b: float, c: float) -> tuple:
    ...
def compute_intersection_between_ray_and_aabb_2d(ray_start_point: numpy.ndarray[numpy.float64[2, 1]], ray_direction: numpy.ndarray[numpy.float64[2, 1]], aabb_min: numpy.ndarray[numpy.float64[2, 1]], aabb_max: numpy.ndarray[numpy.float64[2, 1]]) -> dict:
    ...
def compute_intersection_between_ray_and_aabb_3d(ray_start_point: numpy.ndarray[numpy.float64[3, 1]], ray_direction: numpy.ndarray[numpy.float64[3, 1]], aabb_min: numpy.ndarray[numpy.float64[3, 1]], aabb_max: numpy.ndarray[numpy.float64[3, 1]]) -> dict:
    ...
def compute_intersection_between_ray_and_line_2d(ray_start_point: numpy.ndarray[numpy.float64[2, 1]], ray_direction: numpy.ndarray[numpy.float64[2, 1]], segment_point1: numpy.ndarray[numpy.float64[2, 1]], segment_point2: numpy.ndarray[numpy.float64[2, 1]]) -> tuple:
    ...
def compute_nearest_distance_from_point_to_line_segment_2d(point_x: float, point_y: float, line_segment_x1: float, line_segment_y1: float, line_segment_x2: float, line_segment_y2: float) -> float:
    ...
def compute_pixels_of_polygon_contour(polygon_vertices: numpy.ndarray[numpy.int32[2, n], numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.int32[2, n]]:
    ...
def convert_path_2d_to_3d_float32(path_2d: numpy.ndarray[numpy.float32[3, n], numpy.ndarray.flags.f_contiguous], z: float) -> list[numpy.ndarray[numpy.float32[4, 4]]]:
    ...
def convert_path_2d_to_3d_float64(path_2d: numpy.ndarray[numpy.float64[3, n], numpy.ndarray.flags.f_contiguous], z: float) -> list[numpy.ndarray[numpy.float64[4, 4]]]:
    ...
def create_ellipsoid_mesh(a: float, b: float, c: float, num_azimuths: int = 360, num_elevations: int = 180) -> tuple:
    ...
def find_voxel_indices(codes: torch.Tensor, dims: int, level: int, children: torch.Tensor, parallel: bool = True) -> torch.Tensor:
    """
    Find voxel indices from morton codes and tree structure.
    
    Args:
        codes (torch.Tensor): Tensor of morton code with dtype torch.uint32 or torch.uint64.
        dims (int): Space dimension, 2 or 3.
        level (int): The level to start the search, usually tree_depth - 1.
        children (torch.Tensor): Tensor of shape (M, 2^dims) that stores the tree structure.
        parallel (bool, optional): If true, use parallel for to speed up the search when using CPU. Default is True.
    
    Returns:
        torch.Tensor: Tensor to store the found voxel indices, has the same shape as codes and the same dtype as children.
    """
def hidden_point_removal(points: numpy.ndarray[numpy.float64[3, n], numpy.ndarray.flags.f_contiguous], view_position: numpy.ndarray[numpy.float64[3, 1]], radius: float, fast: bool = False, joggle_inputs: bool = False, return_meshes: bool = False) -> dict:
    """
    Remove hidden points from the point cloud.
    
    Args:
        points: A 3xN matrix of points.
        view_position: The position of the camera.
        radius: The radius of the sphere.
        fast: If true, will run QHull with `Q3 Q5 Q8`.
        joggle_inputs: If true, will run QHull with `QJ`.
    Returns:
        A dictionary containing the visible point indices and optionally the mesh vertices and triangles.
    """
def marching_square(img: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.f_contiguous], iso_value: float) -> tuple:
    ...
def morton_decode(codes: torch.Tensor, dims: int) -> torch.Tensor:
    """
    Decode morton codes to coordinates.
    
    Args:
        codes (torch.Tensor): Tensor of morton code with dtype torch.uint32 or torch.uint64.
        dims (int): Space dimension, 2 or 3.
    
    Returns:
        torch.Tensor: Output tensor of shape (..., dims) with dtype torch.uint16 or torch.uint32.
    """
def morton_encode(coords: torch.Tensor) -> torch.Tensor:
    """
    Encode coordinates to morton codes.
    
    Args:
        coords (torch.Tensor): Tensor of shape (D1, ..., D2, dims) with dtype torch.uint16 or torch.uint32.
    
    Returns:
        torch.Tensor: Output tensor of shape (D1, ..., D2) with dtype torch.uint32 or torch.uint64.
    """
def parallel_hidden_point_removal(points: numpy.ndarray[numpy.float64[3, n], numpy.ndarray.flags.f_contiguous], view_positions: numpy.ndarray[numpy.float64[3, n], numpy.ndarray.flags.f_contiguous], radii: numpy.ndarray[numpy.float64[m, 1]], fast: bool = False, joggle_inputs: bool = False, return_meshes: bool = False) -> dict:
    """
    Remove hidden points from the point cloud w.r.t. multiple camera positions. The function is parallelized.
    
    Args:
        points: A 3xN matrix of points.
        view_positions: A 3xM matrix of camera positions.
        radii: The radius of the spherical projection.
        fast: If true, will run QHull with `Q3 Q5 Q8`.
        joggle_inputs: If true, will run QHull with `QJ`.
    Returns:
        A dictionary containing the visible point indices and optionally the mesh vertices and triangles for each camera position.
    """
def winding_number(p: numpy.ndarray[numpy.float64[2, 1]], vertices: numpy.ndarray[numpy.float64[2, n], numpy.ndarray.flags.f_contiguous]) -> int:
    ...
